<!doctype html><html lang=en dir=auto><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>RL Needed LLMs Because Agency Requires Priors | Shane Caldwell</title>
<meta name=keywords content="llms,rl,research"><meta name=description content="We tried RL once. It didn't work. I'm confident it will this time."><meta name=author content="Shane Caldwell"><link rel=canonical href=http://localhost:1313/writing/rl-llms-and-priors/><link crossorigin=anonymous href=/assets/css/stylesheet.2211ca3164be7830024f6aad2b3a2e520843a64f8f048445c3401c1249aa051d.css integrity="sha256-IhHKMWS+eDACT2qtKzouUghDpk+PBIRFw0AcEkmqBR0=" rel="preload stylesheet" as=style><link rel=icon href=http://localhost:1313/favicon.ico><link rel=icon type=image/png sizes=16x16 href=http://localhost:1313/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=http://localhost:1313/favicon-32x32.png><link rel=apple-touch-icon href=http://localhost:1313/apple-touch-icon-180x180.png><link rel=mask-icon href=http://localhost:1313/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=http://localhost:1313/writing/rl-llms-and-priors/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=icon type=image/x-icon href=/favicon.ico><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon-180x180.png><link rel=apple-touch-icon href=/apple-touch-icon.png><link rel="shortcut icon" href=/favicon.ico><meta name=msapplication-TileColor content="#000000"><meta name=theme-color content="#000000"><script data-goatcounter=https://sjcaldwell.goatcounter.com/count async src=//gc.zgo.at/count.js></script><style>:root{--font-mono:'SF Mono', 'Monaco', 'Inconsolata', 'Roboto Mono', 'Source Code Pro', 'Menlo', 'Consolas', monospace}body,html{font-family:var(--font-mono)!important}*:not(mjx-container):not(mjx-container *),*:not(mjx-container):not(mjx-container *)::before,*:not(mjx-container):not(mjx-container *)::after{font-family:var(--font-mono)!important}mjx-container{overflow-x:visible!important;overflow-y:visible!important;overflow:visible!important}mjx-container[display=true]{display:block!important;text-align:center!important;margin:1em auto!important;max-width:100%!important}mjx-container[display=true] mjx-math{display:inline-block!important;text-align:left!important}mjx-container mjx-mtable{display:table!important;margin:0 auto!important;width:auto!important}mjx-container mjx-mtr{display:table-row!important;height:auto!important}mjx-container mjx-mtd{display:table-cell!important;padding:.3em .8em!important;vertical-align:middle!important}mjx-container[display=true] mjx-mtable mjx-mtr{display:table-row!important;white-space:nowrap!important}mjx-container[display=true] mjx-mtable{display:table!important;border-collapse:separate!important;border-spacing:0 .3em!important}mjx-container::-webkit-scrollbar{display:none!important}mjx-container{-ms-overflow-style:none!important;scrollbar-width:none!important}.dark{--primary:#ffffff;--secondary:#e5e5e5;--tertiary:#cccccc}body:not(.dark){--primary:#000000;--secondary:#333333;--tertiary:#666666}.dark a{color:#fff!important;text-decoration:underline}.dark a:hover{color:#e5e5e5!important}code,pre{font-family:var(--font-mono)!important;font-size:.9em}h1,h2,h3,h4,h5,h6{font-weight:700!important;color:var(--primary)!important}.post-meta{color:var(--secondary)!important}button,.button{font-family:var(--font-mono)!important;font-weight:500}.paper-card,.talk-card{background:var(--theme);border:1px solid var(--border);border-radius:8px;padding:24px;margin-bottom:24px;transition:all .2s ease;box-shadow:0 2px 4px rgba(0,0,0,5%)}.paper-card:hover,.talk-card:hover{border-color:var(--secondary);box-shadow:0 4px 8px rgba(0,0,0,.1);transform:translateY(-1px)}.dark .paper-card,.dark .talk-card{background:#1a1a1a;border-color:#333;box-shadow:0 2px 4px rgba(0,0,0,.2)}.dark .paper-card:hover,.dark .talk-card:hover{border-color:#555;box-shadow:0 4px 8px rgba(0,0,0,.3)}.paper-title{margin:0 0 12px!important;font-size:1.25em;line-height:1.3}.paper-title a{color:var(--primary)!important;text-decoration:none;border-bottom:2px solid transparent;transition:border-color .2s ease}.paper-title a:hover{border-bottom-color:var(--primary)}.paper-meta{margin-bottom:16px;font-size:.9em}.paper-authors{color:var(--secondary);margin-bottom:4px;font-weight:500}.paper-date{color:var(--tertiary);font-size:.85em}.paper-abstract{color:var(--primary);line-height:1.5}.paper-abstract p{margin:0}.talk-title{margin:0 0 12px!important;font-size:1.25em;line-height:1.3}.talk-collaborators{margin-bottom:16px;font-size:.9em;color:var(--secondary)}.talk-collaborators p{margin:0}.talk-details{display:flex;flex-direction:column;gap:8px}.talk-event,.talk-recording{font-size:.9em}.talk-recording a{color:var(--primary)!important;text-decoration:underline}.talk-recording a:hover{color:var(--secondary)!important}@media(max-width:768px){.paper-card,.talk-card{padding:16px;margin-bottom:16px}}.twitter-tweet{margin:24px auto!important;max-width:550px!important}.post-content blockquote.twitter-tweet,.post-content div:has(.twitter-tweet){display:flex;justify-content:center;margin:24px 0}.post-content .twitter-tweet iframe{margin:0 auto;display:block}.post-content figure{margin:24px 0;text-align:center}.post-content figure img{margin-bottom:12px;border-radius:6px;box-shadow:0 4px 8px rgba(0,0,0,.1);max-width:100%;height:auto}.dark .post-content figure img{box-shadow:0 4px 8px rgba(0,0,0,.3)}.post-content figcaption{font-family:var(--font-mono)!important;font-size:.85em;color:var(--secondary);font-style:italic;line-height:1.4;margin-top:8px;padding:0 16px}.post-content figcaption p{margin:0;text-align:center}@media(max-width:768px){.post-content figcaption{font-size:.8em;padding:0 8px}.post-content ol{padding-left:24px!important;margin-left:4px!important}.post-content .footnote-ref{margin-left:2px!important;margin-right:3px!important}.post-content{padding-left:20px!important;padding-right:20px!important}.main{padding-left:8px!important;padding-right:8px!important}}</style><meta property="og:url" content="http://localhost:1313/writing/rl-llms-and-priors/"><meta property="og:site_name" content="Shane Caldwell"><meta property="og:title" content="RL Needed LLMs Because Agency Requires Priors"><meta property="og:description" content="We tried RL once. It didn't work. I'm confident it will this time."><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="writing"><meta property="article:published_time" content="2025-08-19T00:00:00+00:00"><meta property="article:modified_time" content="2025-08-19T00:00:00+00:00"><meta property="article:tag" content="Llms"><meta property="article:tag" content="Rl"><meta property="article:tag" content="Research"><meta property="og:image" content="http://localhost:1313/"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="http://localhost:1313/"><meta name=twitter:title content="RL Needed LLMs Because Agency Requires Priors"><meta name=twitter:description content="We tried RL once. It didn't work. I'm confident it will this time."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Writing","item":"http://localhost:1313/writing/"},{"@type":"ListItem","position":2,"name":"RL Needed LLMs Because Agency Requires Priors","item":"http://localhost:1313/writing/rl-llms-and-priors/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"RL Needed LLMs Because Agency Requires Priors","name":"RL Needed LLMs Because Agency Requires Priors","description":"We tried RL once. It didn't work. I'm confident it will this time.","keywords":["llms","rl","research"],"articleBody":"I’ll begin at the end: RL works better for LLMs than it ever did tabula-rasa or behavioral cloning. The world is, by default, partially observed. Information is imperfect. Strong priors enable you to overcome this. It’s difficult to get stronger, more transferable priors than just grabbing a multi-billion parameter compression of all the data you can find.\nThat’s a strong statement. I’m going to justify it via a rambling retrospective, so I thought I ought to motivate you to read through it.\nAs an AI researcher, I’m focused primarily on LLMs. This is probably no surprise to you - 99% of people doing research are currently LLM people. That’s where the money is, that’s what’s getting turned into products, and that’s where the energy of open-source is. To focus on anything else you need to be particularly motivated.\nWorking in this field as a researcher or engineer, it’s common when talking to others in the field to talk about when you realized LLMs were going to be a big deal. We’re all on the shoulders of giants but if you can say, for example “Oh, I was into attention before the release of GPT-2” that’s better than “GPT-4’s release was a big moment for me”1. My story does not sound great. I was following the AI research broadly, but had a particular distaste for LLMs. That being the case, it took me a little while to catch up.\nHere, I want to provide some historical context and talk about why I wasn’t motivated by LLMs, what’s changed, and why I was wrong.\nI was a web-app pentester for about two years in 2016-2018, fresh out of undergrad. I had a background in bioinformatics that I was choosing not to use in order to stay as far away from academia as possible2. I’d taken a few classes in security and read Hacking: The Art of Exploitation along with The Web Application Hacker’s Handbook. The first six months or so were mostly a continuing undergrad with a provided salary, complete with poor work-life balance and a lot of studying, but I was pretty enamored with the work and confident I’d be happy doing it for the rest of my life.\nThat said, I was 22, and it turns out life is long. At the end of those six months I realized how much I had to learn, but also how much slower my learning process was. In a five day web app test, my schedule could be broken up as follows.\nMonday: Explore the application and map out all of its functionality. Build up the auth matrix I’ll be testing permissions against later. Set up an authenticated Burp Suite scan and get it kicked off.\nTuesday: The client provided a staging deployment with two web workers and half a can of Red Bull, so there’s very little to do but scale back the threads and triage results coming in. Hopefully that finishes today.\nWednesday: Scans done. Go through the rest of the manual checklist, mostly authentication/authorization type checks. Wrap back around to any responses from the scan that weren’t directly exploitable but seemed weird enough that you won’t let it go without getting your hands on it.\nThursday: Here’s the great day. You’ve checked for everything you have to check for and feel confident about it. Now you’re off the checklist, and you’re sniffing out all the weird parts of the application. Every app has some functionality that feels way less “stock” than everything about it and custom development means custom bugs. When I did something I was proud of, it was Thursday.\nFriday: Show’s over, it’s time to report. Make sure you’ve validated and collected evidence for everything before you lose access to the environment, show mastery over the English language and make the reproduction steps you’re not confident anyone is ever going to read much less follow crystal clear. Ship it.\nAfter that initial learning phase, I realized I basically just really enjoyed Thursday. That’s where I felt like a real hacker and not like a guy executing a checklist. Thursday is one day and there are four other ones, so this wasn’t very satisfying. I wanted all my days to be Thursdays. I became interested in automation, and looked around at all the tools that existed for it. There were many clever tools for every element of web app testing, mostly taking advantage of the regularity of HTTP messages and their contents and doing things with regular expressions I honest-to-god didn’t know you could do. But having a machine learning background, they seemed brittle and limited. A list of 1000 regular expressions split among 20 plugins is great and all, but what about some classifiers? I started studying for my OSCP around this time as well, and the heavy recon focus did nothing to disabuse me of the notion ML should be involved3.\nThis was my frame of mind and the kind of problems I was thinking about when I heard about AlphaGo. The competition was over at that point and I could freely access Mastering the game of Go with deep neural networks and tree search. It blew my mind. I was familiar with supervised learning, but maybe had one lecture on reinforcement learning and hadn’t understood what it could be useful for. Now they were combined in this beautiful way and I saw a light at the end of my tunnel. Go is a very difficult game, following a checklist to test webapps is less so. If it could do one, it should be able to do the other. The thing that was most attractive about RL (and still is) is the direct optimization for performance on the task I cared about. Why should I have all my human code taking action based off of classifiers when I could just have it do the thing?\nI wrapped up my OSCP, turned in my two weeks notice, and went back to grad school, sure I would find a way to use deep RL for penetration testing. My confidence increased further when AlphaZero released. There you go! The recipe generalized outside of Go. It generalized to all sorts of games.\nI wasn’t alone in my excitement; far from it. OpenAI was all over it and applying it to everything from robots solving rubik’s cubes to Dota 2. There were pesky technical details dogging everyone, but the general vibe was “they’ll be ironed out if we throw more research at it”. Here are a few technical details we were carefully ignoring, some of which seemed like they could be overcome and some less so. The recipe seemed to generalize well to perfect information games. So what’s missing? You may notice some themes:\nMost environments you would like an agent to operate in do not have perfect information. Pentesting obviously does not, 90% of the game is reconnaissance. You’ve got what is functionally a black box, a picture of which you sketch out by “asking questions” in the form of scans, requests, and various other tools that involve actively gathering information from a target or passively finding it elsewhere. Even when you get as complete a picture as possible externally, you’re still far from perfect information. Progress was made with Poker, a game with imperfect information (but crucially imperfect information you know)\nAction space design is painful and full of human priors. Board games are one thing. Encoding tic-tac-toe moves as vectors is pretty straightforward. Chess requires some creativity, but you can get there. Then you get to Dota 2. At that point you experience pain4.\nEnvironment representation is painful and full of human priors. Beyond the fact that you have to figure out how to represent everything as vectors, what’s really necessary? How are you going to present a web app state as a fixed-size matrix?\nDesigning reward functions is really hard and full of human priors. In particular if you’re doing tabula rasa RL. Any impressive agentic thing you can imagine is just not going to happen from taking random actions. So partial reward functions were used to award the model for going in the vague direction of right. Reward hacking is bad now, reward hacking was so much worse. The most infamous, visually engaging example is probably CoastRunners. It’s a racing game. OpenAI provided partial reward for the agent picking up a powerup that gave you a speed boost. This seems super reasonable, since going fast is likely to get you to win, right? In this case, the agent finds a loop where it can just pickup speed boosts and wirehead itself without ever doing the thing you wanted to do. People were so worried about reward specification problems! It was a non-negligible part of why the AI safety people were going nuts.\nCollecting data is hard. You’d like some supervised data to get some good priors, but your environment and action space are some kind of unholy abomination that only works in the weird framework you made up, so you have to synthetically generate it yourself if you get it at all5\nThen there was the specter of Yann LeCun, taunting us.\nIt still hurts\nMost of those up there come down to pushing humans into a loop you would like them out of. I don’t mean the way we talk about now, like “Claude Code has a human in the loop because I have to ask him to fix stuff”, I mean the deep learning process itself. Neural network architectures represent in some sense, the priors in place on the search space they’re free to optimize over. Ideally you want it to be convenient to find good solutions, and a lot of deep learning tricks back in the day were just that. How do I set my tabula rasa parameters so they’re likely to end up in the good place? How do I make sure my gradient steps are big enough to get out of bad local minima but not so large I never find a good local minimum, etc.\nRL has this whole other part to it, where you’re defining these very key parameters that are deeply encoded into what the network can consider and do. If you don’t provide an action for it, the agent can’t take the action for it. If it’s not wrapped up in the environment representation, the network is blind to it. You now have the priors you set running headlong into engineering realities and compromises. It’s hard, and you’re very involved and iterating on it is very slow. Ultimately, you’d want this representation to be something discovered by the deep learning algorithm. We sweep the hyperparameters for 2% gains, for god’s sake, why would I want a human being to be involved in the most fundamental basic representations of the problem? That’s what we learned from computer vision and natural language - provide the rawest representation possible of the data and let the model figure out what to do with it.\nAll of this seems obvious in retrospect because we just have better options now. At the time, it seemed like the best game in town and like something would just fall into place. Maybe instead of hand-designed environments you’d just have _x_tovec for whatever your environment was and you’d learn a dense representation of it in an unsupervised way and that would be fine. Maybe instead of a reward function you’d use a reward model trained on human preferences. It seemed feasible!\nMy Experience with Deep RL: Metasploit Gym Post graduation I started work as an ML eng mostly doing object detection and image search. This was working with neural nets in prod, which was great, but had nothing to do with agents. When the pandemic happened I found myself with a lot more free time on my hands, and I used a lot of it to read the existing ML offsec literature. There wasn’t a lot I was crazy about. Those systems that did use RL appeared to be largely simulation driven. Simulation is a big word that can mean a lot of different things - I’m not anti-simulation, but a simulation is only as good as its fidelity. Most papers would set up a graph of nodes that represented “attacker boxes” and “defender boxes”. Then they’d have different “attacks” that had particular percentages of success. We’re talking really high level stuff, like one action might be an “SSH exploit” action that had some percentage chance to succeed if the defender box had an “SSH attribute”.\nMy issue with this is very simple - if you can’t take that trained model and swap the actuator for your sim to something that takes action in the real world, I’m not interested. You’re just setting up a system to see if an RL agent can learn ideal strategies for your hermetic world model. I sure hope so! That’s what it’s for.\nSo while I was being mad and reading simulation papers6 I came across this paper: Autonomous Penetration Testing using Reinforcement Learning from Jonathon Schwartz7. I flipped through it and found it was all in simulation, and was preparing myself to get mad again. This section struck me, though:\nPentesters do in fact be using high-level tools.\nThe simulations people were making were in fact pretty simple and “high-level” but were necessary to make the problem tractable with RL. However, hacking tools were already in a sense about making things high-level in order to make it easier to do your job. From this, I basically ignored the simulation part and locked in on the “metasploit is a high level API for hacking” thing, and designed Metasploit Gym around that. I gave a talk on that here if you’re interested, and a blog that goes in depth on what I was thinking at the time. Mostly though I want to use this space to talk about all the problems I ran into.\nAction Space Just a total bear. I had this idea that every metasploit module would start with all the defaults, and could be applied to a particular “service”. This worked for basic stuff, but was a huge flattening of the actual potential action space. Running an nmap scan, for example, involved picking defaults for all the scan parameters and hardcoding them. That allowed it to work, but now there’s loads of behavior that my agent couldn’t express. A lot of the power of frameworks like Metasploit is how configurable the modules are. It couldn’t be more or less stealthy, it couldn’t look for specific things on specific boxes, it was just “scan”. That same basic problem plagues most of the actions.\nEnvironment Representation I essentially chose to represent boxes as vectors and networks as a matrix. So every service could be one-hot encoded for whether it’s on or not. You’ve got HTTP open? That’s a 1 for the HTTP service section, and so on. I didn’t have a way to represent multiple services of the same type, nor did I have a way to surface the version information a scan would provide. I had a vague idea that I could replace the one-hot encoding with a 0 if the service wasn’t on, and a dense word2vec representation to provide more information, but that’s still pretty limited.\nThe network matrix itself was also of fixed-size, meaning there was a maximum number of hosts I could be aware of. If there were less hosts than columns, no big deal, those columns would all stay zero. If there were more? Uhhh. Train a different model, I guess. “Future work”.\nReward Function Design This was potentially the most painful part. In a perfect world, you design a reward function wherein the model is rewarded at some scalar for having done the thing you wanted it to do. In the simplest case with Metasploit Gym, root the box and get some data off of it. Unfortunately, if you don’t get any reward signal, you can’t learn. Randomly choosing actions in our action space means running random modules on random services of random hosts. The vast majority of the time, nothing at all happens.\nSo you need to provide partial reward for something that feels in the direction of the thing you actually would like to provide reward for. Dumb stuff that happened to me:\nI provided reward for scans. Scans are information gathering, and we like recon. Immediately I got reward hacked because each scan got the same amount of reward, and you could wirehead by just scanning all the time. Updated this to only provide reward if new information came in.\nDitto on exploits. Initially had a function for rewarding a successfully run exploit based on the privilege level you got from the resulting shell. Wireheading again, fully rewrote the environment update and reward logic to look at the diff between the previous cumulative environment/privilege level state and the new one in order to determine whether any reward was due. This got ugly.\nInitially the scan was async. The action kicked the scan off and when it was done the agent got that information at whatever timestep the new environment information was available. I didn’t have logic to go back and assign the reward to the action that had actually done the kicking off, and so the reward just got glommed onto some totally random action. Agent immediately zeroes in on that action, despite it having nothing to do with the reward. Quickest fix was making the scan synchronous, which was slow.\nWhich is to say, everything they tell you when you read about RL happened. It was honestly really fun to work on, but I couldn’t help but feel how much of me was being wrapped up into the representation of the environment and the calculation of reward. That doesn’t happen when you write an object detector. All my abstractions were sitting between what I wanted the model optimized to do and how its world was represented.\nA lightbulb that took years to go off StrangeLoop, where I was to present the results of the MetasploitGym was fast approaching, and the model was taking too long to train. There was a lot of basic stuff it was struggling with. Particularly frustrating was how many pointless commands it ran - exploits designed for specific WordPress plugins being shot against SSH services, that kind of thing. Just stuff a person would never do. It made sense given I was starting from nothing, but it wasn’t helpful.\nIt occurred to me that what I wanted was stronger priors. Generating supervised data was going to be hard - even if I wrote code to process my history running metasploit into a supervised format, it would just take too long to generate as a person for my timeline (about a week). So I implemented a simulation, essentially borrowing everything I’d read in all those papers that had made me mad. If an action had no chance of being successful, it got no reward ever. If it was roughly the correct service, it would get reward some percentage of the time. It was more likely to get a reward if it had already scanned and was aware that service was really up, that kind of thing. This allowed me to run purely in simulation for awhile and get those reasonable priors baked in, and I could do the rest of the training in a real environment with the same action/env space with just a different actuator. This allowed me to get a reasonable model for a demo done in time for my presentation8.\nAt the end of the day the results were fine. Random policy solved the box in 20% of 100 episodes tested. Simulated pre-train was roughly 40%, and the future episodes I ran for training weren’t a waste of time. When the policy converged it was capable of rooting the box in 100% of the episodes. I was happy and thought I’d done something clever, regardless of the laundry list of limitations I described above (and training on test).\nLLMs In the meantime GPT-2 is happening, GPT-3 is happening, and I am mostly not interested. People trying to build products out of few-shot prompt autocompletions bugged me. I didn’t like the loss function! Probably because it smelled too much like Yann’s dunking. Also, I was just mad that people at OpenAI were working on this instead of trying to fix all the above-mentioned problems of RL.\nWhen GPT began to be instruction tuned, I could see the value a little more. Working over text still seemed very awkward to me9, but more promising.\nOnce the UI for ChatGPT was released, I decided to give it a swing on solving Hack the Box challenges. Similar to a lot of experiments I did at the time, I just asked it to respond with what I should paste in the console next, and I returned the reply to it, and I just ran it until it fell apart.\nThat command did not, in fact, need a predetermined action space\nIt was a remarkable experience. Commands to install various recon tools just came dropping out. It would see a web service, install gobuster, run it, and start poking around various parts of the application. It didn’t solve any Hack The Box challenges, but the recon was reasonably solid. And look what all those priors could do!\nEven in this infantile state, it was just super clear that nothing I’d done in Metasploit Gym could even compare. There was just no way with the action and environment space I’d written could come up with the commands I was getting out of a model that had been in no way trained to perform the penetration testing task. Maybe if I’d made the action space like, at the character level in a terminal? But that was just tokens but worse.\nIf you wanted more supervised data, that also seemed really reasonable. In fact, it would be basically a cleaner version of what this model was trained on. You would want to collect terminal logs, maybe annotate them a bit. I was very sad about RL not being part of it, but it was just so damned flexible. Even before it was multi-modal you had natbot making these simple textual representations of the browser contents to interact with web applications. I forked it and text-davinci-002 was ripping through the Damn Vulnerable Web App.\nPhilosophically, I was still annoyed. It was nice to know RL was still useful in RLHF, but that wasn’t really what I wanted. There was nowhere in the stack that models were being tuned directly from the objectives I intended for the LLM to be good at. The open model ecosystem improved a lot, and I could freely SFT open models for tasks I cared about. The loss function was still token prediction, though. I couldn’t directly optimize for, say, “hacking”. There was a lot of research community disagreement over whether that mattered. As the models got larger, they seemed to just get better at just about everything. Bar charts were going up. Next-token prediction on transformers was an extremely scalable paradigm and the research investment yielded a huge amount of positive results, so why go back to small scalar rewards and the painful training dynamics of RL?\nPhilosophically annoyed or not, it’s hard to argue with the evals.\nRL Comes Back The models improved at a steady rate throughout 2022-2024. Harnesses that used to need to be totally complex to get a particular behavior could be relaxed. Tool-calling was now very normal, and you could expect structured outputs without a lot of fuss. I still believed that genuinely novel search‑and‑exploit behavior would be limited without real RL. There’s a lot you can do as a lossy compression of high quality SFT trajectories, but were we going to see models perform novel behaviors of interest10?\nI’m not a lab insider, and can’t comment on when RL outside of RLHF became a priority for the labs. Like most people, I was introduced to GRPO (Group Relative Policy Optimization) with the release of DeepSeek-R1. I was, however, incredibly stoked. The models now had a reasonably easy to implement algorithm that let them touch grass with base reality and see real improvements from it.\nShortly thereafter, Will Brown released his infamous gist. I’ve never seen a gist with 1,288 stars and 386 forks before. I’ve also never seen a gist with a BibTeX citation in the top of the docstring. If a gist ever deserved that, though, it was this gist. It made the research extremely accessible to a ton of people really quickly. It’s simply infrequent that you can experiment with the results of a tome-like research paper within a few weeks of its release on a free Google Colab.\nThe task is gsm8k. Let’s take a look at a few of the reward functions:\ndef correctness_reward_func(prompts, completions, answer, **kwargs) -\u003e list[float]: responses = [completion[0]['content'] for completion in completions] q = prompts[0][-1]['content'] extracted_responses = [extract_xml_answer(r) for r in responses] print('-'*20, f\"Question:\\n{q}\", f\"\\nAnswer:\\n{answer[0]}\", f\"\\nResponse:\\n{responses[0]}\", f\"\\nExtracted:\\n{extracted_responses[0]}\") return [2.0 if r == a else 0.0 for r, a in zip(extracted_responses, answer)] Pretty reasonable. You want to assign reward if you get the correct mathematical answer.\nSo what about the rest of them?\ndef strict_format_reward_func(completions, **kwargs) -\u003e list[float]: \"\"\"Reward function that checks if the completion has a specific format.\"\"\" pattern = r\"^\\n.*?\\n\\n\\n.*?\\n\\n$\" responses = [completion[0][\"content\"] for completion in completions] matches = [re.match(pattern, r, flags=re.DOTALL) for r in responses] return [0.5 if match else 0.0 for match in matches] def soft_format_reward_func(completions, **kwargs) -\u003e list[float]: \"\"\"Reward function that checks if the completion has a specific format.\"\"\" pattern = r\".*?\\s*.*?\" responses = [completion[0][\"content\"] for completion in completions] matches = [re.match(pattern, r, flags=re.DOTALL) for r in responses] return [0.5 if match else 0.0 for match in matches] This probably made me happier than I had any right to be. Here was a partial reward function in 2025. Instead of generating hundred or thousands of the appropriate trajectories, just nudge the model with a reward function. In principle there was no reason why this reward had to be calculated from the data instead of from some external reward.\nEverything we used for evals might be directly applicable. Passing unit tests, CTF flags, whatever stable signal you had in your environment from a task was now fair game. It took off immediately. I think because the basics were super easy to grok (thanks Will) and because it felt like it put people who had domain expertise to write good reward functions and construct good environments in the driver’s seat of the tasks they care about without the gargantuan task of dataset collection and cleaning.\nRL does introduce some painful infrastructure problems. Scaling up environments isn’t easy, but it’s in clearly doable in principle. Labs like Nous have spun up frameworks for asynchronous RL with plug and play environments. ART is doing an incredible job making the training itself very easy. The recipe hasn’t been canonized, yet, but it will be in a few years. That’s not to say it’s not extremely difficult, just that it’s now doable. You can grab one of the increasingly capable open models off the shelf, and if you put in the elbow grease to create difficult, realistic environments, you can train a model directly on the objectives you care about using RL. It’s very exciting. Everything old is new again, and there are tons of papers to be written where you take something that worked for Deep Q-Networks (DQNs) and figure out if you can make it practical or useful for LLMs. We all get to talk about credit assignment again.\nConclusions: Agency Requires Priors The book isn’t closed on RLVR (reinforcement learning from verifiable rewards). Nathan Lambert from AI2 said on the Latent Space podcast a few weeks ago that he wasn’t including a ton on RLVR in his upcoming RLHF book because it’ll be years before the research solidifies enough for a book to be written. Without speaking to where it might go, I just want to talk a little bit about how different training LLMs in these paradigms feels compared to that Metasploit Gym work.\nThe action space and environment space have just opened up to an insane degree. Tools (actions) can be modified without any change in the underlying code running the model. This is also true for the environment. You can represent whatever you want through text and images in as raw a form as you like. The limitations are around what you can bring from the environment. The demo environment you set up can grow to be more mature, there’s a ton less for you to think about. This experience of trying to map to matrices just isn’t a thing. I think that explains a lot of the agent demos you see on Twitter - it’s just ludicrously easy to write up an API for a tool nobody has given a model access to before, run it, see something cool, and post it.\nThe priors are also just stupidly powerful. If your model is trained to use tools, it will use your tools. If your tools enable a task to be solved, it’s entirely plausible you don’t even need to write a partial reward function. The reward hacking that falls out of trying to coax a successful episode out of a tabula-rasa model is just not a thing you have to engage in as often. If you can evaluate it, you can reward it. Many evals - unit tests, CTF flags, compile/run checks, reconciliation diffs - are already verifiable signals. LLMs + tools surface the state; RLVR converts those checks into training signals. If you want to hear more about the benefits of evals, (and why you should write your own) I speak on that here.\nThat’s how I think about LLMs now. This giant collection of priors and inductive bias that provide a really beautiful general starting point for whatever task you want to do post-training on. It’s on us to figure out how to design and deploy the environments this reward signal will come from in a scalable way, but it feels like a little elbow grease in comparison to the myriad of things holding us back in 2019.\nSo, maybe Yann was right after all about RL. We just didn’t predict we’d be given a cake covered in frosting and given the enviable task of figuring out how to put the cherry on top.\nCrucially, note that this does not matter and mostly has nothing to say about somebody’s intelligence or research intuition. This is purely a social game we play amongst ourselves. In another life we would be comparing front lawn products, or something. I’m not saying I don’t participate, I’m just saying it’s a dumb thing to do. ↩︎\nLoved the analysis, but Biology is so violently slow and frequently irreproducible that I think it would’ve killed me. Popping shells provides the more immediate feedback I need to function. ↩︎\nYeah, man, you gotta run like 1000 scans and then read them over and over again until you develop an intuition for what’s worth triaging. That’s classification! You’re making me a classifier! ↩︎\nTo be clear, I deeply admire this work. This paper was my coping mechanism whenever I couldn’t think of a way forward on pentesting. The fact that there were compromises involved in the action and environment representation are just showing how killer engineers made the research they had stretch to the agent they wanted to make. It’s awesome. ↩︎\nThis is a clue that will help you later! ↩︎\nMost of my research ideas come from this. That’s probably true for a lot of people. ↩︎\nHe’s not really into the infosec domain anymore, but I still like to shout him out. He answered my emails back in the day and just seems like a bright guy. Thanks Jonathon! ↩︎\nThat, and my buddy Grady’s home Proxmox lab. Thanks, Grady! Thanks, Proxmox! Truly never seen faster environment resets in my life. I literally didn’t even implement logic to check whether the reset was done before the next episode started because Grady’s Proxmox server was so fast. ↩︎\nHonestly even funny to remember that was a problem seeing how good structured output has become. ↩︎\nThere’s an argument made that you wouldn’t need that in order to be economically valuable. Obviously it was true to an extent, because a huge amount of people invested in the advantages of “semantics-aware programming” that the models provided in order to make startups across all sorts of interesting verticals. I don’t want to see economically interesting behavior operating at the average of a human-generated training set, though. I want to see AI generate novel exploits. ↩︎\n","wordCount":"5458","inLanguage":"en","image":"http://localhost:1313/","datePublished":"2025-08-19T00:00:00Z","dateModified":"2025-08-19T00:00:00Z","author":{"@type":"Person","name":"Shane Caldwell"},"mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:1313/writing/rl-llms-and-priors/"},"publisher":{"@type":"Organization","name":"Shane Caldwell","logo":{"@type":"ImageObject","url":"http://localhost:1313/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=http://localhost:1313/ accesskey=h title="Shane Caldwell (Alt + H)">Shane Caldwell</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=http://localhost:1313/ title=Main><span>Main</span></a></li><li><a href=http://localhost:1313/papers/ title=Papers><span>Papers</span></a></li><li><a href=http://localhost:1313/talks/ title=Talks><span>Talks</span></a></li><li><a href=http://localhost:1313/writing/ title=Writing><span>Writing</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">RL Needed LLMs Because Agency Requires Priors</h1><div class=post-description>We tried RL once. It didn't work. I'm confident it will this time.</div><div class=post-meta><span title='2025-08-19 00:00:00 +0000 UTC'>August 19, 2025</span>&nbsp;·&nbsp;26 min&nbsp;·&nbsp;5458 words&nbsp;·&nbsp;Shane Caldwell</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#my-experience-with-deep-rl-metasploit-gym>My Experience with Deep RL: Metasploit Gym</a><ul><li><a href=#action-space>Action Space</a></li><li><a href=#environment-representation>Environment Representation</a></li><li><a href=#reward-function-design>Reward Function Design</a></li><li><a href=#a-lightbulb-that-took-years-to-go-off>A lightbulb that took years to go off</a></li></ul></li><li><a href=#llms>LLMs</a><ul><li><a href=#rl-comes-back>RL Comes Back</a></li></ul></li><li><a href=#conclusions-agency-requires-priors>Conclusions: Agency Requires Priors</a></li></ul></nav></div></details></div><div class=post-content><p>I&rsquo;ll begin at the end: RL works better for LLMs than it ever did tabula-rasa or behavioral cloning. The world is, by default, partially observed. Information is imperfect. Strong priors enable you to overcome this. It&rsquo;s difficult to get stronger, more transferable priors than just grabbing a multi-billion parameter compression of all the data you can find.</p><p>That&rsquo;s a strong statement. I&rsquo;m going to justify it via a rambling retrospective, so I thought I ought to motivate you to read through it.</p><p>As an AI researcher, I&rsquo;m focused primarily on LLMs. This is probably no surprise to you - 99% of people doing research are currently LLM people. That&rsquo;s where the money is, that&rsquo;s what&rsquo;s getting turned into products, and that&rsquo;s where the energy of open-source is. To focus on anything else you need to be particularly motivated.</p><p>Working in this field as a researcher or engineer, it&rsquo;s common when talking to others in the field to talk about <em>when</em> you realized LLMs were going to be a big deal. We&rsquo;re all on the shoulders of giants but if you can say, for example &ldquo;Oh, I was into attention before the release of GPT-2&rdquo; that&rsquo;s better than &ldquo;GPT-4&rsquo;s release was a big moment for me&rdquo;<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup>. My story does not sound great. I was following the AI research broadly, but had a particular distaste for LLMs. That being the case, it took me a little while to catch up.</p><p>Here, I want to provide some historical context and talk about why I wasn&rsquo;t motivated by LLMs, what&rsquo;s changed, and why I was wrong.</p><p>I was a web-app pentester for about two years in 2016-2018, fresh out of undergrad. I had a background in bioinformatics that I was choosing not to use in order to stay as far away from academia as possible<sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup>. I&rsquo;d taken a few classes in security and read <a href=https://en.wikipedia.org/wiki/Hacking:_The_Art_of_Exploitation>Hacking: The Art of Exploitation</a> along with <a href=https://www.oreilly.com/library/view/the-web-application/9781118026472/>The Web Application Hacker&rsquo;s Handbook</a>. The first six months or so were mostly a continuing undergrad with a provided salary, complete with poor work-life balance and a lot of studying, but I was pretty enamored with the work and confident I&rsquo;d be happy doing it for the rest of my life.</p><p>That said, I was 22, and it turns out life is long. At the end of those six months I realized how much I had to learn, but also how much slower my learning process was. In a five day web app test, my schedule could be broken up as follows.</p><ol><li><p>Monday: Explore the application and map out all of its functionality. Build up the auth matrix I&rsquo;ll be testing permissions against later. Set up an authenticated Burp Suite scan and get it kicked off.</p></li><li><p>Tuesday: The client provided a staging deployment with two web workers and half a can of Red Bull, so there&rsquo;s very little to do but scale back the threads and triage results coming in. Hopefully that finishes today.</p></li><li><p>Wednesday: Scans done. Go through the rest of the manual checklist, mostly authentication/authorization type checks. Wrap back around to any responses from the scan that weren&rsquo;t directly exploitable but seemed weird enough that you won&rsquo;t let it go without getting your hands on it.</p></li><li><p>Thursday: Here&rsquo;s the great day. You&rsquo;ve checked for everything you <em>have</em> to check for and feel confident about it. Now you&rsquo;re off the checklist, and you&rsquo;re sniffing out all the weird parts of the application. Every app has some functionality that feels way less &ldquo;stock&rdquo; than everything about it and custom development means custom bugs. When I did something I was proud of, it was Thursday.</p></li><li><p>Friday: Show&rsquo;s over, it&rsquo;s time to report. Make sure you&rsquo;ve validated and collected evidence for everything before you lose access to the environment, show mastery over the English language and make the reproduction steps you&rsquo;re not confident anyone is ever going to read much less follow crystal clear. Ship it.</p></li></ol><p>After that initial learning phase, I realized I basically just really enjoyed Thursday. That&rsquo;s where I felt like a <em>real hacker</em> and not like a guy executing a checklist. Thursday is one day and there are four other ones, so this wasn&rsquo;t very satisfying. I wanted all my days to be Thursdays. I became interested in automation, and looked around at all the tools that existed for it. There were many clever tools for every element of web app testing, mostly taking advantage of the regularity of HTTP messages and their contents and doing things with regular expressions I honest-to-god didn&rsquo;t know you could do. But having a machine learning background, they seemed brittle and limited. A list of 1000 regular expressions split among 20 plugins is great and all, but what about some classifiers? I started studying for my OSCP around this time as well, and the heavy recon focus did nothing to disabuse me of the notion ML should be involved<sup id=fnref:3><a href=#fn:3 class=footnote-ref role=doc-noteref>3</a></sup>.</p><p>This was my frame of mind and the kind of problems I was thinking about when I heard about AlphaGo. The competition was over at that point and I could freely access <a href=https://www.nature.com/articles/nature16961>Mastering the game of Go with deep neural networks and tree search</a>. It blew my mind. I was familiar with supervised learning, but maybe had one lecture on reinforcement learning and hadn&rsquo;t understood what it could be useful for. Now they were combined in this beautiful way and I saw a light at the end of my tunnel. Go is a very difficult game, following a checklist to test webapps is less so. If it could do one, it should be able to do the other. The thing that was most attractive about RL (and still is) is the direct optimization for performance on the task I cared about. Why should I have all my human code taking action based off of classifiers when I could just have it do the thing?</p><p>I wrapped up my OSCP, turned in my two weeks notice, and went back to grad school, sure I would find a way to use deep RL for penetration testing. My confidence increased further when <a href=https://deepmind.google/discover/blog/alphazero-shedding-new-light-on-chess-shogi-and-go/>AlphaZero</a> released. There you go! The recipe generalized outside of Go. It generalized to all sorts of games.</p><p>I wasn&rsquo;t alone in my excitement; far from it. OpenAI was <a href=https://spinningup.openai.com/en/latest/>all over it</a> and applying it to everything from <a href=https://openai.com/index/solving-rubiks-cube/>robots solving rubik&rsquo;s cubes</a> to <a href=https://openai.com/index/openai-five/>Dota 2</a>. There were pesky technical details dogging everyone, but the general vibe was &ldquo;they&rsquo;ll be ironed out if we throw more research at it&rdquo;. Here are a few technical details we were carefully ignoring, some of which seemed like they could be overcome and some less so. The recipe seemed to generalize well to <em>perfect information games</em>. So what&rsquo;s missing? You may notice some themes:</p><ol><li><p>Most environments you would like an agent to operate in <em>do not</em> have perfect information. Pentesting obviously does not, 90% of the game is reconnaissance. You&rsquo;ve got what is functionally a black box, a picture of which you sketch out by &ldquo;asking questions&rdquo; in the form of scans, requests, and various other tools that involve actively gathering information from a target or passively finding it elsewhere. Even when you get as complete a picture as possible externally, you&rsquo;re still far from perfect information. Progress was made with <a href=https://arxiv.org/abs/2007.13544>Poker</a>, a game with imperfect information (but crucially imperfect information you know)</p></li><li><p>Action space design is painful and full of human priors. Board games are one thing. Encoding tic-tac-toe moves as vectors is pretty straightforward. Chess requires some creativity, but you can get there. Then you get to Dota 2. At that point you experience <a href=https://arxiv.org/abs/1912.06680>pain</a><sup id=fnref:4><a href=#fn:4 class=footnote-ref role=doc-noteref>4</a></sup>.</p></li><li><p>Environment representation is painful and full of human priors. Beyond the fact that you have to figure out how to represent everything as vectors, what&rsquo;s really necessary? How are you going to present a web app state as a fixed-size matrix?</p></li><li><p>Designing reward functions is really hard and full of human priors. In particular if you&rsquo;re doing tabula rasa RL. Any impressive agentic thing you can imagine is just not going to happen from taking random actions. So partial reward functions were used to award the model for going in the vague direction of right. Reward hacking is bad now, reward hacking was so much worse. The most infamous, visually engaging example is probably <a href="https://www.youtube.com/watch?v=tlOIHko8ySg">CoastRunners</a>. It&rsquo;s a racing game. OpenAI provided partial reward for the agent picking up a powerup that gave you a speed boost. This seems super reasonable, since going fast is likely to get you to win, right? In this case, the agent finds a loop where it can just pickup speed boosts and wirehead itself without ever doing the thing you wanted to do. People were so worried about reward specification problems! It was a non-negligible part of why the AI safety people were going nuts.</p></li><li><p>Collecting data is hard. You&rsquo;d like some supervised data to get some good priors, but your environment and action space are some kind of unholy abomination that only works in the weird framework you made up, so you have to synthetically generate it yourself if you get it at all<sup id=fnref:5><a href=#fn:5 class=footnote-ref role=doc-noteref>5</a></sup></p></li></ol><p>Then there was the specter of Yann LeCun, taunting us.</p><figure><img loading=lazy src=yann_cake_taunts.jpeg alt="A slide from a Yann LeCun presentation in NeurIPS 2016"><figcaption><p>It still hurts</p></figcaption></figure><p>Most of those up there come down to pushing humans <em>into</em> a loop you would like them out of. I don&rsquo;t mean the way we talk about now, like &ldquo;Claude Code has a human in the loop because I have to ask him to fix stuff&rdquo;, I mean the deep learning process itself. Neural network architectures represent in some sense, the priors in place on the search space they&rsquo;re free to optimize over. Ideally you want it to be convenient to find good solutions, and a lot of deep learning tricks back in the day were just that. How do I set my tabula rasa parameters so they&rsquo;re likely to end up in the good place? How do I make sure my gradient steps are big enough to get out of bad local minima but not so large I never find a good local minimum, etc.</p><p>RL has this whole other part to it, where you&rsquo;re defining these very key parameters that are deeply encoded into what the network can consider and do. If you don&rsquo;t provide an action for it, the agent can&rsquo;t take the action for it. If it&rsquo;s not wrapped up in the environment representation, the network is blind to it. You now have the priors you set running headlong into engineering realities and compromises. It&rsquo;s hard, and you&rsquo;re <em>very</em> involved and iterating on it is <em>very</em> slow. Ultimately, you&rsquo;d want this representation to be something discovered by the deep learning algorithm. We sweep the hyperparameters for 2% gains, for god&rsquo;s sake, why would I want a human being to be involved in the most fundamental basic representations of the problem? That&rsquo;s what we learned from computer vision and natural language - provide the rawest representation possible of the data and let the model figure out what to do with it.</p><p>All of this seems obvious in retrospect because we just have better options now. At the time, it seemed like the best game in town and like something would just fall into place. Maybe instead of hand-designed environments you&rsquo;d just have _x_tovec for whatever your environment was and you&rsquo;d learn a dense representation of it in an unsupervised way and that would be fine. Maybe instead of a reward function you&rsquo;d use a reward model trained on <a href=https://arxiv.org/abs/1706.03741>human preferences</a>. It seemed feasible!</p><h2 id=my-experience-with-deep-rl-metasploit-gym>My Experience with Deep RL: Metasploit Gym<a hidden class=anchor aria-hidden=true href=#my-experience-with-deep-rl-metasploit-gym>#</a></h2><p>Post graduation I started work as an ML eng mostly doing object detection and image search. This was working with neural nets in prod, which was great, but had nothing to do with agents. When the pandemic happened I found myself with a lot more free time on my hands, and I used a lot of it to read the existing ML offsec literature. There wasn&rsquo;t a lot I was crazy about. Those systems that did use RL appeared to be largely simulation driven. Simulation is a big word that can mean a lot of different things - I&rsquo;m not <em>anti</em>-simulation, but a simulation is only as good as its fidelity. Most papers would set up a graph of nodes that represented &ldquo;attacker boxes&rdquo; and &ldquo;defender boxes&rdquo;. Then they&rsquo;d have different &ldquo;attacks&rdquo; that had particular percentages of success. We&rsquo;re talking really high level stuff, like one action might be an &ldquo;SSH exploit&rdquo; action that had some percentage chance to succeed if the defender box had an &ldquo;SSH attribute&rdquo;.</p><p>My issue with this is very simple - if you can&rsquo;t take that trained model and swap the actuator for your sim to something that takes action in the real world, I&rsquo;m not interested. You&rsquo;re just setting up a system to see if an RL agent can learn ideal strategies for your hermetic world model. I sure hope so! That&rsquo;s what it&rsquo;s for.</p><p>So while I was being mad and reading simulation papers<sup id=fnref:6><a href=#fn:6 class=footnote-ref role=doc-noteref>6</a></sup> I came across this paper: <a href=https://arxiv.org/abs/1905.05965>Autonomous Penetration Testing using Reinforcement Learning</a> from <a href=https://jjschwartz.github.io/>Jonathon Schwartz</a><sup id=fnref:7><a href=#fn:7 class=footnote-ref role=doc-noteref>7</a></sup>. I flipped through it and found it was all in simulation, and was preparing myself to get mad again. This section struck me, though:</p><figure><img loading=lazy src=abstraction.png alt="An excerpt from page 16 of the above mentioned thesis"><figcaption><p>Pentesters do in fact be using high-level tools.</p></figcaption></figure><p>The simulations people were making were in fact pretty simple and &ldquo;high-level&rdquo; but were necessary to make the problem tractable with RL. However, hacking tools were already in a sense about making things high-level in order to make it easier to do your job. From this, I basically ignored the simulation part and locked in on the &ldquo;metasploit is a high level API for hacking&rdquo; thing, and designed <a href=https://github.com/phreakAI/metasploit-gym>Metasploit Gym</a> around that. I gave a talk on that <a href="https://www.youtube.com/watch?v=EiI69BdWKPs">here</a> if you&rsquo;re interested, and a <a href=https://hackbot.dad/writing/towards-autonomous-pentesting/>blog</a> that goes in depth on what I was thinking at the time. Mostly though I want to use this space to talk about all the problems I ran into.</p><h3 id=action-space>Action Space<a hidden class=anchor aria-hidden=true href=#action-space>#</a></h3><p>Just a total bear. I had this idea that every metasploit module would start with all the defaults, and could be applied to a particular &ldquo;service&rdquo;. This worked for basic stuff, but was a huge flattening of the actual potential action space. Running an nmap scan, for example, involved picking defaults for all the scan parameters and hardcoding them. That allowed it to work, but now there&rsquo;s loads of behavior that my agent couldn&rsquo;t express. A lot of the power of frameworks like Metasploit is how configurable the modules are. It couldn&rsquo;t be more or less stealthy, it couldn&rsquo;t look for specific things on specific boxes, it was just &ldquo;scan&rdquo;. That same basic problem plagues most of the actions.</p><h3 id=environment-representation>Environment Representation<a hidden class=anchor aria-hidden=true href=#environment-representation>#</a></h3><p>I essentially chose to represent boxes as vectors and networks as a matrix. So every service could be one-hot encoded for whether it&rsquo;s on or not. You&rsquo;ve got HTTP open? That&rsquo;s a 1 for the HTTP service section, and so on. I didn&rsquo;t have a way to represent multiple services of the same type, nor did I have a way to surface the version information a scan would provide. I had a vague idea that I could replace the one-hot encoding with a 0 if the service wasn&rsquo;t on, and a dense word2vec representation to provide more information, but that&rsquo;s still pretty limited.</p><p>The network matrix itself was also of fixed-size, meaning there was a maximum number of hosts I could be aware of. If there were less hosts than columns, no big deal, those columns would all stay zero. If there were more? Uhhh. Train a different model, I guess. &ldquo;Future work&rdquo;.</p><h3 id=reward-function-design>Reward Function Design<a hidden class=anchor aria-hidden=true href=#reward-function-design>#</a></h3><p>This was potentially the most painful part. In a perfect world, you design a reward function wherein the model is rewarded at some scalar for having done the thing you wanted it to do. In the simplest case with Metasploit Gym, root the box and get some data off of it. Unfortunately, if you don&rsquo;t get <em>any</em> reward signal, you can&rsquo;t learn. Randomly choosing actions in our action space means running random modules on random services of random hosts. The vast majority of the time, nothing at all happens.</p><p>So you need to provide partial reward for something that feels <em>in the direction</em> of the thing you actually would like to provide reward for. Dumb stuff that happened to me:</p><ol><li><p>I provided reward for scans. Scans are information gathering, and we like recon. Immediately I got reward hacked because each scan got the same amount of reward, and you could wirehead by just scanning all the time. Updated this to only provide reward if new information came in.</p></li><li><p>Ditto on exploits. Initially had a function for rewarding a successfully run exploit based on the privilege level you got from the resulting shell. Wireheading again, fully rewrote the environment update and reward logic to look at the diff between the previous cumulative environment/privilege level state and the new one in order to determine whether any reward was due. This got ugly.</p></li><li><p>Initially the scan was async. The action kicked the scan off and when it was done the agent got that information at whatever timestep the new environment information was available. I didn&rsquo;t have logic to go back and assign the reward to the action that had actually done the kicking off, and so the reward just got glommed onto some totally random action. Agent immediately zeroes in on that action, despite it having nothing to do with the reward. Quickest fix was making the scan synchronous, which was slow.</p></li></ol><p>Which is to say, everything they tell you when you read about RL happened. It was honestly really fun to work on, but I couldn&rsquo;t help but feel how much of <em>me</em> was being wrapped up into the representation of the environment and the calculation of reward. That doesn&rsquo;t happen when you write an object detector. All my abstractions were sitting between what I wanted the model optimized to do and how its world was represented.</p><h3 id=a-lightbulb-that-took-years-to-go-off>A lightbulb that took years to go off<a hidden class=anchor aria-hidden=true href=#a-lightbulb-that-took-years-to-go-off>#</a></h3><p>StrangeLoop, where I was to present the results of the MetasploitGym was fast approaching, and the model was taking too long to train. There was a lot of basic stuff it was struggling with. Particularly frustrating was how many pointless commands it ran - exploits designed for specific WordPress plugins being shot against SSH services, that kind of thing. Just stuff a person would never do. It made sense given I was starting from nothing, but it wasn&rsquo;t helpful.</p><p>It occurred to me that what I wanted was stronger priors. Generating supervised data was going to be hard - even if I wrote code to process my history running metasploit into a supervised format, it would just take too long to generate as a person for my timeline (about a week). So I implemented a simulation, essentially borrowing everything I&rsquo;d read in all those papers that had made me mad. If an action had no chance of being successful, it got no reward ever. If it was roughly the correct service, it would get reward some percentage of the time. It was more likely to get a reward if it had already scanned and was aware that service was really up, that kind of thing. This allowed me to run purely in simulation for awhile and get those reasonable priors baked in, and I could do the rest of the training in a real environment with the same action/env space with just a different actuator. This allowed me to get a reasonable model for a demo done in time for my presentation<sup id=fnref:8><a href=#fn:8 class=footnote-ref role=doc-noteref>8</a></sup>.</p><p>At the end of the day the results were fine. Random policy solved the box in 20% of 100 episodes tested. Simulated pre-train was roughly 40%, and the future episodes I ran for training weren&rsquo;t a waste of time. When the policy converged it was capable of rooting the box in 100% of the episodes. I was happy and thought I&rsquo;d done something clever, regardless of the laundry list of limitations I described above (and training on test).</p><h2 id=llms>LLMs<a hidden class=anchor aria-hidden=true href=#llms>#</a></h2><p>In the meantime GPT-2 is happening, GPT-3 is happening, and I am mostly not interested. People trying to build products out of few-shot prompt autocompletions bugged me. I didn&rsquo;t like the loss function! Probably because it smelled too much like Yann&rsquo;s dunking. Also, I was just mad that people at OpenAI were working on this instead of trying to fix all the above-mentioned problems of RL.</p><p>When GPT began to be instruction tuned, I could see the value a little more. Working over text still seemed very awkward to me<sup id=fnref:9><a href=#fn:9 class=footnote-ref role=doc-noteref>9</a></sup>, but more promising.</p><p>Once the UI for ChatGPT was released, I decided to give it a swing on solving Hack the Box challenges. Similar to a lot of experiments I did at the time, I just asked it to respond with what I should paste in the console next, and I returned the reply to it, and I just ran it until it fell apart.</p><figure><img loading=lazy src=htb_feb12_2023.png alt="One of my first ChatGPT interactions, wherein an nmap command comes out"><figcaption><p>That command did not, in fact, need a predetermined action space</p></figcaption></figure><p>It was a remarkable experience. Commands to install various recon tools just came dropping out. It would see a web service, install gobuster, run it, and start poking around various parts of the application. It didn&rsquo;t solve any Hack The Box challenges, but the recon was reasonably solid. And look what all those <em>priors</em> could do!</p><p>Even in this infantile state, it was just super clear that nothing I&rsquo;d done in Metasploit Gym could even compare. There was just no way with the action and environment space I&rsquo;d written could come up with the commands I was getting out of a model that had been in no way trained to perform the penetration testing task. Maybe if I&rsquo;d made the action space like, at the character level in a terminal? But that was just tokens but worse.</p><p>If you wanted more supervised data, that also seemed really reasonable. In fact, it would be basically a cleaner version of what this model was trained on. You would want to collect terminal logs, maybe annotate them a bit. I was very sad about RL not being part of it, but it was just so damned flexible. Even before it was multi-modal you had <a href=https://github.com/nat/natbot>natbot</a> making these simple textual representations of the browser contents to interact with web applications. I <a href=https://github.com/SJCaldwell/phreakbot>forked it</a> and <code>text-davinci-002</code> was ripping through the Damn Vulnerable Web App.</p><p>Philosophically, I was still annoyed. It was nice to know RL was still useful in RLHF, but that wasn&rsquo;t really what I wanted. There was nowhere in the stack that models were being tuned directly from the objectives <em>I</em> intended for the LLM to be good at. The open model ecosystem improved a lot, and I could freely SFT open models for tasks I cared about. The loss function was still token prediction, though. I couldn&rsquo;t directly optimize for, say, &ldquo;hacking&rdquo;. There was a lot of research community disagreement over whether that mattered. As the models got larger, they seemed to just <em>get better</em> at just about everything. Bar charts were going up. Next-token prediction on transformers was an extremely scalable paradigm and the research investment yielded a huge amount of positive results, so why go back to small scalar rewards and the painful training dynamics of RL?</p><p>Philosophically annoyed or not, it&rsquo;s hard to argue with the evals.</p><h3 id=rl-comes-back>RL Comes Back<a hidden class=anchor aria-hidden=true href=#rl-comes-back>#</a></h3><p>The models improved at a steady rate throughout 2022-2024. Harnesses that used to need to be totally complex to get a particular behavior could be relaxed. Tool-calling was now very normal, and you could expect structured outputs without a lot of fuss. I still believed that genuinely novel search‑and‑exploit behavior would be limited without real RL. There&rsquo;s a lot you can do as a lossy compression of high quality SFT trajectories, but were we going to see models perform novel behaviors of interest<sup id=fnref:10><a href=#fn:10 class=footnote-ref role=doc-noteref>10</a></sup>?</p><p>I&rsquo;m not a lab insider, and can&rsquo;t comment on when RL outside of RLHF became a priority for the labs. Like most people, I was introduced to GRPO (Group Relative Policy Optimization) with the release of <a href=https://arxiv.org/abs/2501.12948>DeepSeek-R1</a>. I was, however, incredibly stoked. The models now had a reasonably easy to implement algorithm that let them touch grass with base reality and see real improvements from it.</p><p>Shortly thereafter, <a href="https://x.com/willccbb?lang=en">Will Brown</a> released his infamous <a href=https://gist.github.com/willccbb/4676755236bb08cab5f4e54a0475d6fb>gist</a>. I&rsquo;ve never seen a gist with 1,288 stars and 386 forks before. I&rsquo;ve also never seen a gist with a BibTeX citation in the top of the docstring. If a gist ever deserved that, though, it was this gist. It made the research extremely accessible to a ton of people really quickly. It&rsquo;s simply infrequent that you can experiment with the results of a tome-like research paper within a few weeks of its release on a free Google Colab.</p><p>The task is <a href=https://huggingface.co/datasets/openai/gsm8k>gsm8k</a>. Let&rsquo;s take a look at a few of the reward functions:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>correctness_reward_func</span><span class=p>(</span><span class=n>prompts</span><span class=p>,</span> <span class=n>completions</span><span class=p>,</span> <span class=n>answer</span><span class=p>,</span> <span class=o>**</span><span class=n>kwargs</span><span class=p>)</span> <span class=o>-&gt;</span> <span class=nb>list</span><span class=p>[</span><span class=nb>float</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>    <span class=n>responses</span> <span class=o>=</span> <span class=p>[</span><span class=n>completion</span><span class=p>[</span><span class=mi>0</span><span class=p>][</span><span class=s1>&#39;content&#39;</span><span class=p>]</span> <span class=k>for</span> <span class=n>completion</span> <span class=ow>in</span> <span class=n>completions</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    <span class=n>q</span> <span class=o>=</span> <span class=n>prompts</span><span class=p>[</span><span class=mi>0</span><span class=p>][</span><span class=o>-</span><span class=mi>1</span><span class=p>][</span><span class=s1>&#39;content&#39;</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    <span class=n>extracted_responses</span> <span class=o>=</span> <span class=p>[</span><span class=n>extract_xml_answer</span><span class=p>(</span><span class=n>r</span><span class=p>)</span> <span class=k>for</span> <span class=n>r</span> <span class=ow>in</span> <span class=n>responses</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=s1>&#39;-&#39;</span><span class=o>*</span><span class=mi>20</span><span class=p>,</span> <span class=sa>f</span><span class=s2>&#34;Question:</span><span class=se>\n</span><span class=si>{</span><span class=n>q</span><span class=si>}</span><span class=s2>&#34;</span><span class=p>,</span> <span class=sa>f</span><span class=s2>&#34;</span><span class=se>\n</span><span class=s2>Answer:</span><span class=se>\n</span><span class=si>{</span><span class=n>answer</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span><span class=si>}</span><span class=s2>&#34;</span><span class=p>,</span> <span class=sa>f</span><span class=s2>&#34;</span><span class=se>\n</span><span class=s2>Response:</span><span class=se>\n</span><span class=si>{</span><span class=n>responses</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span><span class=si>}</span><span class=s2>&#34;</span><span class=p>,</span> <span class=sa>f</span><span class=s2>&#34;</span><span class=se>\n</span><span class=s2>Extracted:</span><span class=se>\n</span><span class=si>{</span><span class=n>extracted_responses</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span><span class=si>}</span><span class=s2>&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=p>[</span><span class=mf>2.0</span> <span class=k>if</span> <span class=n>r</span> <span class=o>==</span> <span class=n>a</span> <span class=k>else</span> <span class=mf>0.0</span> <span class=k>for</span> <span class=n>r</span><span class=p>,</span> <span class=n>a</span> <span class=ow>in</span> <span class=nb>zip</span><span class=p>(</span><span class=n>extracted_responses</span><span class=p>,</span> <span class=n>answer</span><span class=p>)]</span>
</span></span></code></pre></div><p>Pretty reasonable. You want to assign reward if you get the correct mathematical answer.</p><p>So what about the rest of them?</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>strict_format_reward_func</span><span class=p>(</span><span class=n>completions</span><span class=p>,</span> <span class=o>**</span><span class=n>kwargs</span><span class=p>)</span> <span class=o>-&gt;</span> <span class=nb>list</span><span class=p>[</span><span class=nb>float</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;&#34;&#34;Reward function that checks if the completion has a specific format.&#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>    <span class=n>pattern</span> <span class=o>=</span> <span class=sa>r</span><span class=s2>&#34;^&lt;reasoning&gt;\n.*?\n&lt;/reasoning&gt;\n&lt;answer&gt;\n.*?\n&lt;/answer&gt;\n$&#34;</span>
</span></span><span class=line><span class=cl>    <span class=n>responses</span> <span class=o>=</span> <span class=p>[</span><span class=n>completion</span><span class=p>[</span><span class=mi>0</span><span class=p>][</span><span class=s2>&#34;content&#34;</span><span class=p>]</span> <span class=k>for</span> <span class=n>completion</span> <span class=ow>in</span> <span class=n>completions</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    <span class=n>matches</span> <span class=o>=</span> <span class=p>[</span><span class=n>re</span><span class=o>.</span><span class=k>match</span><span class=p>(</span><span class=n>pattern</span><span class=p>,</span> <span class=n>r</span><span class=p>,</span> <span class=n>flags</span><span class=o>=</span><span class=n>re</span><span class=o>.</span><span class=n>DOTALL</span><span class=p>)</span> <span class=k>for</span> <span class=n>r</span> <span class=ow>in</span> <span class=n>responses</span><span class=p>]</span> 
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=p>[</span><span class=mf>0.5</span> <span class=k>if</span> <span class=k>match</span> <span class=k>else</span> <span class=mf>0.0</span> <span class=k>for</span> <span class=k>match</span> <span class=ow>in</span> <span class=n>matches</span><span class=p>]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>soft_format_reward_func</span><span class=p>(</span><span class=n>completions</span><span class=p>,</span> <span class=o>**</span><span class=n>kwargs</span><span class=p>)</span> <span class=o>-&gt;</span> <span class=nb>list</span><span class=p>[</span><span class=nb>float</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;&#34;&#34;Reward function that checks if the completion has a specific format.&#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>    <span class=n>pattern</span> <span class=o>=</span> <span class=sa>r</span><span class=s2>&#34;&lt;reasoning&gt;.*?&lt;/reasoning&gt;\s*&lt;answer&gt;.*?&lt;/answer&gt;&#34;</span>
</span></span><span class=line><span class=cl>    <span class=n>responses</span> <span class=o>=</span> <span class=p>[</span><span class=n>completion</span><span class=p>[</span><span class=mi>0</span><span class=p>][</span><span class=s2>&#34;content&#34;</span><span class=p>]</span> <span class=k>for</span> <span class=n>completion</span> <span class=ow>in</span> <span class=n>completions</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    <span class=n>matches</span> <span class=o>=</span> <span class=p>[</span><span class=n>re</span><span class=o>.</span><span class=k>match</span><span class=p>(</span><span class=n>pattern</span><span class=p>,</span> <span class=n>r</span><span class=p>,</span> <span class=n>flags</span><span class=o>=</span><span class=n>re</span><span class=o>.</span><span class=n>DOTALL</span><span class=p>)</span> <span class=k>for</span> <span class=n>r</span> <span class=ow>in</span> <span class=n>responses</span><span class=p>]</span> 
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=p>[</span><span class=mf>0.5</span> <span class=k>if</span> <span class=k>match</span> <span class=k>else</span> <span class=mf>0.0</span> <span class=k>for</span> <span class=k>match</span> <span class=ow>in</span> <span class=n>matches</span><span class=p>]</span>
</span></span></code></pre></div><p>This probably made me happier than I had any right to be. Here was a <em>partial reward function</em> in 2025. Instead of generating hundred or thousands of the appropriate trajectories, just nudge the model with a reward function. In principle there was no reason why this reward had to be calculated from the data instead of from some external reward.</p><p>Everything we used for evals might be directly applicable. Passing unit tests, CTF flags, whatever stable signal you had in your environment from a task was now fair game. It took off immediately. I think because the basics were super easy to grok (thanks Will) and because it felt like it put people who had domain expertise to write good reward functions and construct good environments in the driver&rsquo;s seat of the tasks they care about without the gargantuan task of dataset collection and cleaning.</p><p>RL does introduce some painful infrastructure problems. Scaling up environments isn&rsquo;t easy, but it&rsquo;s in clearly doable in principle. Labs like Nous have spun up frameworks for <a href=https://github.com/NousResearch/atropos>asynchronous RL</a> with plug and play environments. <a href=https://github.com/OpenPipe/ART>ART</a> is doing an incredible job making the training itself very easy. The recipe hasn&rsquo;t been canonized, yet, but it will be in a few years. That&rsquo;s not to say it&rsquo;s not extremely difficult, just that it&rsquo;s now doable. You can grab one of the increasingly capable open models off the shelf, and if you put in the elbow grease to create difficult, realistic environments, you can train a model directly on the objectives you care about using RL. It&rsquo;s very exciting. Everything old is new again, and there are tons of papers to be written where you take something that worked for Deep Q-Networks (DQNs) and figure out if you can make it practical or useful for LLMs. We all get to talk about credit assignment again.</p><h2 id=conclusions-agency-requires-priors>Conclusions: Agency Requires Priors<a hidden class=anchor aria-hidden=true href=#conclusions-agency-requires-priors>#</a></h2><p>The book isn&rsquo;t closed on RLVR (reinforcement learning from verifiable rewards). Nathan Lambert from AI2 said on the <a href="https://www.youtube.com/watch?v=PAz_-xPJcRM">Latent Space</a> podcast a few weeks ago that he wasn&rsquo;t including a ton on RLVR in his upcoming RLHF book because it&rsquo;ll be years before the research solidifies enough for a book to be written. Without speaking to where it might go, I just want to talk a little bit about how different training LLMs in these paradigms <em>feels</em> compared to that <a href=https://github.com/phreakAI/metasploit-gym>Metasploit Gym</a> work.</p><p>The action space and environment space have just opened up to an insane degree. Tools (actions) can be modified without any change in the underlying code running the model. This is also true for the environment. You can represent whatever you want through text and images in as raw a form as you like. The limitations are around what you can bring from the environment. The demo environment you set up can grow to be more mature, there&rsquo;s a ton less for you to think about. This experience of trying to map to matrices just isn&rsquo;t a thing. I think that explains a lot of the agent demos you see on Twitter - it&rsquo;s just ludicrously easy to write up an API for a tool nobody has given a model access to before, run it, see something cool, and post it.</p><p>The priors are also just stupidly powerful. If your model is trained to use tools, it will use your tools. If your tools enable a task to be solved, it&rsquo;s entirely plausible you don&rsquo;t even need to write a partial reward function. The reward hacking that falls out of trying to coax a successful episode out of a tabula-rasa model is just not a thing you have to engage in as often. If you can evaluate it, you can reward it. Many evals - unit tests, CTF flags, compile/run checks, reconciliation diffs - are already verifiable signals. LLMs + tools surface the state; RLVR converts those checks into training signals. If you want to hear more about the benefits of evals, (and why you should write your own) I speak on that <a href=https://hackbot.dad/writing/agony-and-ecstasy-evals/>here</a>.</p><p>That&rsquo;s how I think about LLMs now. This giant collection of priors and inductive bias that provide a really beautiful general starting point for whatever task you want to do post-training on. It&rsquo;s on us to figure out how to design and deploy the environments this reward signal will come from in a scalable way, but it feels like a little elbow grease in comparison to the myriad of things holding us back in 2019.</p><p>So, maybe Yann was right after all about RL. We just didn&rsquo;t predict we&rsquo;d be given a cake covered in frosting and given the enviable task of figuring out how to put the cherry on top.</p><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p>Crucially, note that this <em>does not matter</em> and mostly has nothing to say about somebody&rsquo;s intelligence or research intuition. This is purely a social game we play amongst ourselves. In another life we would be comparing front lawn products, or something. I&rsquo;m not saying I don&rsquo;t participate, I&rsquo;m just saying it&rsquo;s a dumb thing to do.&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:2><p>Loved the analysis, but Biology is so violently slow and frequently irreproducible that I think it would&rsquo;ve killed me. Popping shells provides the more immediate feedback I need to function.&#160;<a href=#fnref:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:3><p>Yeah, man, you gotta run like 1000 scans and then read them over and over again until you develop an intuition for what&rsquo;s worth triaging. That&rsquo;s classification! You&rsquo;re making me a classifier!&#160;<a href=#fnref:3 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:4><p>To be clear, I deeply admire this work. This paper was my coping mechanism whenever I couldn&rsquo;t think of a way forward on pentesting. The fact that there were compromises involved in the action and environment representation are just showing how killer engineers made the research they had stretch to the agent they wanted to make. It&rsquo;s awesome.&#160;<a href=#fnref:4 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:5><p>This is a clue that will help you later!&#160;<a href=#fnref:5 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:6><p>Most of my research ideas come from this. That&rsquo;s probably true for a lot of people.&#160;<a href=#fnref:6 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:7><p>He&rsquo;s not really into the infosec domain anymore, but I still like to shout him out. He answered my emails back in the day and just seems like a bright guy. Thanks Jonathon!&#160;<a href=#fnref:7 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:8><p>That, and my buddy Grady&rsquo;s home Proxmox lab. Thanks, Grady! Thanks, Proxmox! Truly never seen faster environment resets in my life. I literally didn&rsquo;t even implement logic to check whether the reset was done before the next episode started because Grady&rsquo;s Proxmox server was so fast.&#160;<a href=#fnref:8 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:9><p>Honestly even funny to remember that was a problem seeing how good structured output has become.&#160;<a href=#fnref:9 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:10><p>There&rsquo;s an argument made that you wouldn&rsquo;t <em>need</em> that in order to be economically valuable. Obviously it was true to an extent, because a huge amount of people invested in the advantages of &ldquo;semantics-aware programming&rdquo; that the models provided in order to make startups across all sorts of interesting verticals. I don&rsquo;t want to see economically interesting behavior operating at the average of a human-generated training set, though. I want to see AI generate novel exploits.&#160;<a href=#fnref:10 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div></div><footer class=post-footer><ul class=post-tags><li><a href=http://localhost:1313/tags/llms/>Llms</a></li><li><a href=http://localhost:1313/tags/rl/>Rl</a></li><li><a href=http://localhost:1313/tags/research/>Research</a></li></ul><nav class=paginav><a class=prev href=http://localhost:1313/writing/data-parallelism-for-the-poor/><span class=title>« Prev</span><br><span>DiLoCo: Data Parallelism for the Datacenter Poor</span>
</a><a class=next href=http://localhost:1313/writing/agony-and-ecstasy-evals/><span class=title>Next »</span><br><span>GPT-5 is Good, Actually: The Agony and Ecstasy of Public Benchmarks</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2026 <a href=http://localhost:1313/>Shane Caldwell</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><style>.copy-code{display:inline-flex;align-items:center;justify-content:center;width:32px;height:32px;background:var(--tertiary);border:1px solid var(--border);border-radius:6px;color:var(--secondary);cursor:pointer;transition:all .2s ease;position:absolute;top:8px;right:8px;z-index:10}.copy-code:hover{background:var(--secondary);color:var(--theme)}.copy-code svg{width:16px;height:16px}.copy,.highlight .copy{display:none!important}pre{position:relative}</style><script>document.addEventListener("DOMContentLoaded",function(){document.querySelectorAll('.copy, [class*="copy"]').forEach(e=>{e.classList.contains("copy-code")||e.remove()});const e=document.querySelectorAll("pre");e.forEach(e=>{const t=e.cloneNode(!0);e.parentNode.replaceChild(t,e)}),document.querySelectorAll("pre code").forEach(e=>{const n=e.parentElement;if(n.querySelector(".copy-code"))return;const t=document.createElement("button");t.classList.add("copy-code"),t.setAttribute("aria-label","Copy code"),t.setAttribute("type","button");const s=`<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect width="14" height="14" x="8" y="8" rx="2" ry="2"/><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"/></svg>`,a=`<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M20 6L9 17l-5-5"/></svg>`;t.innerHTML=s;function o(){t.innerHTML=a,t.style.color="#10b981",setTimeout(()=>{t.innerHTML=s,t.style.color=""},2e3)}t.addEventListener("click",function(t){t.preventDefault(),t.stopPropagation();const n=e.textContent||e.innerText;navigator.clipboard?navigator.clipboard.writeText(n).then(()=>{o()}).catch(()=>{i(n)}):i(n)});function i(e){const t=document.createElement("textarea");t.value=e,t.style.position="fixed",t.style.opacity="0",document.body.appendChild(t),t.select();try{document.execCommand("copy"),o()}catch(e){console.error("Copy failed:",e)}document.body.removeChild(t)}n.appendChild(t)})})</script><script>window.MathJax={tex:{inlineMath:[["$","$"],["\\(","\\)"]],displayMath:[["$$","$$"],["\\[","\\]"]],processEscapes:!0,processEnvironments:!0},chtml:{scale:1,mtextInheritFont:!1,matchFontHeight:!1},options:{skipHtmlTags:["script","noscript","style","textarea","pre"]},startup:{pageReady:()=>MathJax.startup.defaultPageReady().then(()=>{document.querySelectorAll("mjx-container").forEach(e=>{e.style.overflow="visible"})})}}</script><script id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js></script><style>.footnote-popup{position:absolute;background:var(--theme);border:1px solid var(--border);border-radius:6px;padding:12px 16px;max-width:300px;font-size:.85em;line-height:1.4;z-index:1000;box-shadow:0 4px 12px rgba(0,0,0,.15);font-family:var(--font-mono);color:var(--primary);display:none;pointer-events:auto;word-wrap:break-word}.dark .footnote-popup{background:#2d2d2d;box-shadow:0 4px 12px rgba(0,0,0,.3)}.footnote-popup::before{content:'';position:absolute;top:-6px;left:50%;transform:translateX(-50%);width:12px;height:12px;background:var(--theme);border:1px solid var(--border);border-bottom:none;border-right:none;rotate:45deg}.dark .footnote-popup::before{background:#2d2d2d}.footnote-ref{text-decoration:none!important;font-weight:700;padding:2px 6px;border-radius:4px;background:var(--primary);color:var(--theme)!important;transition:all .2s ease;position:relative;border:1px solid var(--border);font-size:.8em;line-height:1.2;display:inline-block;min-width:18px;text-align:center;margin:0 1px;vertical-align:baseline}.footnote-ref:hover{background:var(--secondary);color:var(--theme)!important;box-shadow:0 2px 4px rgba(0,0,0,.2)}.dark .footnote-ref{background:#fff;color:#000!important;border:1px solid #666}.dark .footnote-ref:hover{background:#e5e5e5;color:#000!important;box-shadow:0 2px 6px rgba(0,0,0,.4)}</style><script>document.addEventListener("DOMContentLoaded",function(){let e=null,t=null;function s(e,t){const n=document.createElement("div");return n.className="footnote-popup",n.innerHTML=t,document.body.appendChild(n),n}function o(n,s){t&&(clearTimeout(t),t=null);const i=n.getBoundingClientRect(),r=s.getBoundingClientRect();let o=i.left+i.width/2-s.offsetWidth/2,a=i.top-s.offsetHeight-10;o<10&&(o=10),o+s.offsetWidth>window.innerWidth-10&&(o=window.innerWidth-s.offsetWidth-10),a<10&&(a=i.bottom+10),s.style.left=o+window.scrollX+"px",s.style.top=a+window.scrollY+"px",s.style.display="block",e=s}function n(){t=setTimeout(()=>{e&&(e.style.display="none",e=null)},150)}document.querySelectorAll("a.footnote-ref").forEach(e=>{const i=e.getAttribute("href");if(!i)return;const r=document.querySelector(i.replace(/:/g,"\\:"));if(!r)return;const c=r.innerHTML.replace(/<a[^>]*href="#fnref[^"]*"[^>]*>.*?<\/a>/g,"").trim();if(!c)return;const a=s(i,c);e.addEventListener("mouseenter",()=>{o(e,a)}),e.addEventListener("mouseleave",n),a.addEventListener("mouseenter",()=>{t&&(clearTimeout(t),t=null)}),a.addEventListener("mouseleave",n)}),window.addEventListener("scroll",()=>{e&&(e.style.display="none",e=null)})})</script><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>