<!doctype html><html lang=en dir=auto><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>DiLoCo: Data Parallelism for the Datacenter Poor | Shane Caldwell</title>
<meta name=keywords content="llms,training,distributed"><meta name=description content="Distributed training sans datacenter."><meta name=author content="Shane Caldwell"><link rel=canonical href=http://localhost:1313/writing/data-parallelism-for-the-poor/><link crossorigin=anonymous href=/assets/css/stylesheet.2211ca3164be7830024f6aad2b3a2e520843a64f8f048445c3401c1249aa051d.css integrity="sha256-IhHKMWS+eDACT2qtKzouUghDpk+PBIRFw0AcEkmqBR0=" rel="preload stylesheet" as=style><link rel=icon href=http://localhost:1313/favicon.ico><link rel=icon type=image/png sizes=16x16 href=http://localhost:1313/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=http://localhost:1313/favicon-32x32.png><link rel=apple-touch-icon href=http://localhost:1313/apple-touch-icon-180x180.png><link rel=mask-icon href=http://localhost:1313/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=http://localhost:1313/writing/data-parallelism-for-the-poor/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=icon type=image/x-icon href=/favicon.ico><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon-180x180.png><link rel=apple-touch-icon href=/apple-touch-icon.png><link rel="shortcut icon" href=/favicon.ico><meta name=msapplication-TileColor content="#000000"><meta name=theme-color content="#000000"><script data-goatcounter=https://sjcaldwell.goatcounter.com/count async src=//gc.zgo.at/count.js></script><style>:root{--font-mono:'SF Mono', 'Monaco', 'Inconsolata', 'Roboto Mono', 'Source Code Pro', 'Menlo', 'Consolas', monospace}body,html{font-family:var(--font-mono)!important}*:not(mjx-container):not(mjx-container *),*:not(mjx-container):not(mjx-container *)::before,*:not(mjx-container):not(mjx-container *)::after{font-family:var(--font-mono)!important}mjx-container{overflow-x:visible!important;overflow-y:visible!important;overflow:visible!important}mjx-container[display=true]{display:block!important;text-align:center!important;margin:1em auto!important;max-width:100%!important}mjx-container[display=true] mjx-math{display:inline-block!important;text-align:left!important}mjx-container mjx-mtable{display:table!important;margin:0 auto!important;width:auto!important}mjx-container mjx-mtr{display:table-row!important;height:auto!important}mjx-container mjx-mtd{display:table-cell!important;padding:.3em .8em!important;vertical-align:middle!important}mjx-container[display=true] mjx-mtable mjx-mtr{display:table-row!important;white-space:nowrap!important}mjx-container[display=true] mjx-mtable{display:table!important;border-collapse:separate!important;border-spacing:0 .3em!important}mjx-container::-webkit-scrollbar{display:none!important}mjx-container{-ms-overflow-style:none!important;scrollbar-width:none!important}.dark{--primary:#ffffff;--secondary:#e5e5e5;--tertiary:#cccccc}body:not(.dark){--primary:#000000;--secondary:#333333;--tertiary:#666666}.dark a{color:#fff!important;text-decoration:underline}.dark a:hover{color:#e5e5e5!important}code,pre{font-family:var(--font-mono)!important;font-size:.9em}h1,h2,h3,h4,h5,h6{font-weight:700!important;color:var(--primary)!important}.post-meta{color:var(--secondary)!important}button,.button{font-family:var(--font-mono)!important;font-weight:500}.paper-card,.talk-card{background:var(--theme);border:1px solid var(--border);border-radius:8px;padding:24px;margin-bottom:24px;transition:all .2s ease;box-shadow:0 2px 4px rgba(0,0,0,5%)}.paper-card:hover,.talk-card:hover{border-color:var(--secondary);box-shadow:0 4px 8px rgba(0,0,0,.1);transform:translateY(-1px)}.dark .paper-card,.dark .talk-card{background:#1a1a1a;border-color:#333;box-shadow:0 2px 4px rgba(0,0,0,.2)}.dark .paper-card:hover,.dark .talk-card:hover{border-color:#555;box-shadow:0 4px 8px rgba(0,0,0,.3)}.paper-title{margin:0 0 12px!important;font-size:1.25em;line-height:1.3}.paper-title a{color:var(--primary)!important;text-decoration:none;border-bottom:2px solid transparent;transition:border-color .2s ease}.paper-title a:hover{border-bottom-color:var(--primary)}.paper-meta{margin-bottom:16px;font-size:.9em}.paper-authors{color:var(--secondary);margin-bottom:4px;font-weight:500}.paper-date{color:var(--tertiary);font-size:.85em}.paper-abstract{color:var(--primary);line-height:1.5}.paper-abstract p{margin:0}.talk-title{margin:0 0 12px!important;font-size:1.25em;line-height:1.3}.talk-collaborators{margin-bottom:16px;font-size:.9em;color:var(--secondary)}.talk-collaborators p{margin:0}.talk-details{display:flex;flex-direction:column;gap:8px}.talk-event,.talk-recording{font-size:.9em}.talk-recording a{color:var(--primary)!important;text-decoration:underline}.talk-recording a:hover{color:var(--secondary)!important}@media(max-width:768px){.paper-card,.talk-card{padding:16px;margin-bottom:16px}}.twitter-tweet{margin:24px auto!important;max-width:550px!important}.post-content blockquote.twitter-tweet,.post-content div:has(.twitter-tweet){display:flex;justify-content:center;margin:24px 0}.post-content .twitter-tweet iframe{margin:0 auto;display:block}.post-content figure{margin:24px 0;text-align:center}.post-content figure img{margin-bottom:12px;border-radius:6px;box-shadow:0 4px 8px rgba(0,0,0,.1);max-width:100%;height:auto}.dark .post-content figure img{box-shadow:0 4px 8px rgba(0,0,0,.3)}.post-content figcaption{font-family:var(--font-mono)!important;font-size:.85em;color:var(--secondary);font-style:italic;line-height:1.4;margin-top:8px;padding:0 16px}.post-content figcaption p{margin:0;text-align:center}@media(max-width:768px){.post-content figcaption{font-size:.8em;padding:0 8px}.post-content ol{padding-left:24px!important;margin-left:4px!important}.post-content .footnote-ref{margin-left:2px!important;margin-right:3px!important}.post-content{padding-left:20px!important;padding-right:20px!important}.main{padding-left:8px!important;padding-right:8px!important}}</style><meta property="og:url" content="http://localhost:1313/writing/data-parallelism-for-the-poor/"><meta property="og:site_name" content="Shane Caldwell"><meta property="og:title" content="DiLoCo: Data Parallelism for the Datacenter Poor"><meta property="og:description" content="Distributed training sans datacenter."><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="writing"><meta property="article:published_time" content="2025-10-03T00:00:00+00:00"><meta property="article:modified_time" content="2025-10-03T00:00:00+00:00"><meta property="article:tag" content="Llms"><meta property="article:tag" content="Training"><meta property="article:tag" content="Distributed"><meta property="og:image" content="http://localhost:1313/"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="http://localhost:1313/"><meta name=twitter:title content="DiLoCo: Data Parallelism for the Datacenter Poor"><meta name=twitter:description content="Distributed training sans datacenter."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Writing","item":"http://localhost:1313/writing/"},{"@type":"ListItem","position":2,"name":"DiLoCo: Data Parallelism for the Datacenter Poor","item":"http://localhost:1313/writing/data-parallelism-for-the-poor/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"DiLoCo: Data Parallelism for the Datacenter Poor","name":"DiLoCo: Data Parallelism for the Datacenter Poor","description":"Distributed training sans datacenter.","keywords":["llms","training","distributed"],"articleBody":"I’m a big believer in private models. I always have been. The term “local” model still strikes me as strange, because it was previously the default. We’d just call them models. If we had to refer to a third party hosted model, we’d just say “the default google model” or whatever, and that was generally derogatory.\nPart of this is just when I started in the field. I became an ML engineer in 2018, and finetuning or training models from scratch was just what you did. There were a few API-based models you could call, but outside of sentiment analysis they were nearly all uniformly very bad. My friends and I mostly used them as evidence to our boss that we needed to invest more budget in training1.\nAnother part of this is a sort of functional professional paranoia. If I put out a product, I’m in some sense responsible for its reliability. If you’re an API wrapper, there’s very little guarantees you can make. Will my performance be consistent? Will the model be up? Will I wake up one day to find the model is deprecated? I have no idea, man, I just call the API and hope for the best. There are benefits to this, sure, your product can just get better with no effort on your part, but it can also just get worse or stop existing.\nFinally, and most important to me if I’m being honest, it’s a professional pride thing. I’m a scientist and an engineer, and for the largest part of my career my responsibility has been making models. You want some weights that do a thing, I go through the effort of collecting data, training a model, iterating on it, serving it, improving it. It feels really good to do. You end up being SOTA at some insanely domain-specific stuff. For several years I worked primarily on object detection for household objects for a moving company. The amount of mental energy I spent on data augmentation for occlusion would boggle your mind. To go through that effort and see it work gives you an insane amount of dopamine. Calling an API, frankly, doesn’t hit the same.\nSo, to reduce the probability of calling APIs for the rest of my life, it’s time to hit the books.\nHitting the Books The goal is to competently train competitively performant LLMs. I’ve done quite a bit of finetuning of smaller models. Take an A100 and a small Qwen or Llama, finetune it for some particular task, or do a little GRPO. But to train something larger (\u003e30B) and on longer context lengths (128k), I need some skillsets I don’t have. In-particular, distributed training.\nOver the past eight years I’ve been in the field, multi-gpu and multi-node training has gone from a nice-to-have to necessity. Working in computer vision, I might be finetuning a YOLOv8 model that had, on the upper end, around 50M parameters. Running out of GPU memory wasn’t a significant concern of mine. When I had access to multiple GPUs, my primary dimension of parallelization was running different training jobs on each GPU in order to speed up hyper-parameter sweep. It’s likely I could have trained slightly faster if I had invested time in becoming comfortable with the torch profiler, but it just wasn’t a showstopper. The compute was relatively cheap. In general, I found it was much more productive to spend time looking at the data, collecting more data, and introducing new data augmentations. I only looked into serious performance improvements for models when I was putting them on mobile, and that could mostly be done with some kernel fusion and futzing with torch.compile. High performance distributed training just wasn’t a muscle I stretched very often.\nNecessity, however, is the mother of getting-your-act-together.\nI bounced off The Ultra-Scale Playbook a few times. Mostly just because I was reading it and not applying it2. The concepts are all there, the exercises are more choose-your-own-adventure. The correct course of action was to just pick something and work on it, but when you’re busy it helps if you’ve got a little bit of handholding and lot of forcing function. Thankfully, I got the forcing function I was looking for with Scratch to Scale from Zach Mueller, a class on taking the many distributed techniques necessary for making large model training practical and making you implement them. In addition, he had a totally insane set of lecturers from Unsloth, Prime Intellect, Ray, Huggingface, etc, each of whom is world-class at their particular part of the stack.\nI’m not an online class person. I hate my schedule being dictated by someone else. I’ve got a job for that! But the syllabus looked like exactly what I was looking for, and it was. Zach’s a great lecturer and everything I kinda-sorta “knew” from reading about parallelism techniques from different places is now in my bones from working on those implementations. I’m confident it will help me out a ton on my main research focus: training really competent, really small judges for post-training. Thanks Zach! I’ll be back for that post-training class.\nSpeaking of implementations I’ve gotten cozy with, let’s talk about the simplest and most vanilla of the parallelisms: data parallelism. Then we can talk about how to make it work if you happen to have misplaced your datacenter (DiLoCo).\nWhy Scale? We’ll start with some assumptions. First, let’s assume you’re interested in pre-training. Lots of models on a large batch size. Second, let’s assume that the model you want to train fits entirely in GPU memory, for at least one batch during training and that model is going to be trained in full precision (FP32). Let’s go over what is going to need to fit into memory. Before we even start talking about activations, let’s go over parameters, gradients, and optimizer states. We’ll calculate all this in terms of bytes.\nFirst,\n$$m_{params} = 4 * N$$ Each parameter is four bytes (32 bit precision). So if you’re training a 7B parameter model, you’ve got $4 * (7*10^9)$. There are $10^9$ bytes in a gigabyte, that’s 24GB right there.\nNext, you’ve got,\n$$m_{grad} = 4 * N$$ You’ve got FP32 gradients for each parameter in the model during the backward pass. That’s another 24GB of memory.\nFinally, you’ve got: $$m_{opt}= (4 + 4) * N$$ This won’t be the same for all optimizers. But let’s say we’re using standard Adam. Adam is going to store the momentum and variance in FP32 for each parameter. So that’s an additional 48GB of memory.\nSo, assuming we’re using FP32, we’re at 96GB already, before we’ve even computed an activation. All that for a measly 7B parameter model. No wonder people feel GPU poor.\nSo 7B was ambitious for fitting on a single card. I just wanted to write it out because 7B is chump change and already has you reaching for different techniques to distribute memory over multiple cards/nodes3. For the purposes of this post, let’s assume our model is smaller. Call it a ~1B parameter model. Those same calculations would give us 2GB for model parameters, 2GB for gradients, and 4GB for optimizers. A healthy 8GB that would fit on most consumer grade cards. It’s also the size of GPT-2 XL, so you’re at least in the 2019 tech tree.\nNow let’s pick a target batch size. Our target-batch size should be at the token level. OpenAI’s Language Models are Few-Shot Learners gives us as good a place as any to start for our humble 1(.3)B parameter model.\nOn Teslas is crazy\nA batch size of 1 million tokens. If our dataset has 1024 tokens in each sample, that means we’d want roughly:\n$$\\text{Number of samples} = \\left\\lfloor \\frac{\\text{Total tokens in batch}}{\\text{Tokens per sequence}} \\right\\rfloor = \\left\\lfloor \\frac{1 \\times 10^6}{1024} \\right\\rfloor \\approx 976$$976 samples! Intuitively you probably understand that’s not going to fit in your forward pass. But exactly how much is it not going to fit in your forward pass? To really grok this we’re going to need to consider activation memory, which we’ve been avoiding because it’s slightly more complicated, and it’s going to stick around through the backward pass.\nThe Ultrascale playbook lists it, for mixed precision with each element requiring two bytes of storage:\n$$m_{act} = L\\cdot seq \\cdot bs \\cdot h \\cdot (34 + \\dfrac{5 \\cdot n_{heads} \\cdot seq}{h})$$$L$ is the number of layers, $seq$ is sequence length, $bs$ is batch size per sample, and $h$ is the hidden dimension of the model, $n_{heads}$ is the number of heads.\nWe can simply double this in order to get to FP32. Already you can see the result is going to be quadratic with respect to sequence length, which will dominate here. Let’s go ahead and fill out these values.\n$$\\begin{align} L \u0026= 48 \\text{ (n\\_layer)} \\\\ seq \u0026= 1024 \\text{ (n\\_ctx)} \\\\ bs \u0026= 976 \\text{ (your batch size)} \\\\ h \u0026= 1600 \\text{ (n\\_embd)} \\\\ n_{heads} \u0026= 25 \\text{ (n\\_head)} \\\\ \\\\ m_{act} \u0026= L \\cdot seq \\cdot bs \\cdot h \\cdot \\left(34 + \\frac{5 \\cdot n_{heads} \\cdot seq}{h}\\right) \\\\ \\\\ \u0026= 48 \\times 1024 \\times 976 \\times 1600 \\times \\left(34 + \\frac{5 \\times 25 \\times 1024}{1600}\\right) \\\\ \\\\ \u0026= 48 \\times 1024 \\times 976 \\times 1600 \\times \\left(34 + \\frac{128,000}{1600}\\right) \\\\ \\\\ \u0026= 48 \\times 1024 \\times 976 \\times 1600 \\times (34 + 80) \\\\ \\\\ \u0026= 48 \\times 1024 \\times 976 \\times 1600 \\times 114 \\\\ \\\\ \u0026= 8,765,317,734,400 \\text{ elements} \\\\ \u0026\\approx 8.77 \\times 10^{12} \\text{ elements} \\end{align}$$ Multiply by two to get into FP32, and you’re looking at $17.5 \\cdot 10^{12}$ bytes. That ends up being 17,500 GB of VRAM for a forward pass, or roughly 17.5 terabytes of VRAM. That’s not gonna work on a single forward pass on a single card. Not on your 4090, not on an A100, not on an H100.\nAll that, mind you, as pre-training for a 1.5B parameter model. They go north of a trillion in parameter count, on sequences much longer than 1024 elements. So we’ll need some tricks. We’ll talk about two now: gradient accumulation and data parallelism.\nGradient Accumulation The elites don’t want you to know you don’t have to called optimizer.step() immediately after loss.backwards(). You can do it whenever you feel like it!\nIf you’ve got a target batch size on a particular GPU but the activations are too large to send all of them in one go, you can break them up into micro-batches. Say you can only fit two samples in the forward/backward pass, but you want a batch size of eight. You can Just break up four micro-batches, successively running the forward and backward passes. Finally you can average the gradients and perform the optimizer step.\nSo your real batch size now looks like:\n$$batch\\space size = micro\\space batch \\space size \\times gradient\\space accumulation\\space steps $$So in principle, as long as you can do a forward/backward pass with at least one sample, you can increase your batch size to whatever you please while holding the memory footprint constant on our single GPU. In our example, you could run the forward/backward pass 976 times to get to the token batch size you were looking for. In principle, you could train GPT-2XL on a single consumer card!\nIn reality, needing to perform 976 forward/backward passes before your optimizer step is throwing some serious compute overhead down, and your wall clock time will be in terms of years. So - you could do it, but it’s not what serious people do. And we’re very serious people. What else do we have?\nMore GPUs.\nData Parallelism Data parallelism is ultimately about increasing your effective batch size, similar to gradient accumulation, just with more parallel FLOPs.\nThe basic idea is that we will replicate our model (which fits on a single card, remember!) onto multiple cards. Those cards could be on the same node, or cards on nodes in the same data center. If we keep the gradient accumulation steps we had before, our effective global batch size will be multiplied by the number of replicas.\n$$batch\\space size = num\\space replicas \\times micro\\space batch \\space size \\times gradient\\space accumulation\\space steps $$If you’ve got a target batch size, then this is a recipe for reaching it. Find out what your maximum micro batch size is, decide how many GPUs you have access to, and then fill in the gaps with gradient accumulation.\nA Brief Interlude On Distributed Torch Before we get started, a few definitions you’ll need to know as we go through code when we’re talking about distributed training. You’ve got some arbitrary number of workers that you’d like your code to be essentially independent of. This model is called Single Program Multiple Data (SPMD). The same program is running on multiple workers with different data, and each executes independently within their own interpreters, communicating when they need to. Terms it’ll be helpful to know follow:\nWorld Size: This refers to the total number of processes/GPUs. So if you fired up two nodes with four GPUs a piece, the world size is 8. They are, however, zero-indexed.\nLocal Rank: This refers to the rank within a single node. That will go from 0 to the number of gpus per node, minus one. So if you have four gpus per box, that’s 0-3.\nRank: This is the global rank from 0 to world size minus one. That is, 0 to 7 in this case.\nSince you’re shipping the same program to multiple workers, a common pattern you’ll see reading distributed torch code is a conditional to check if you’re the rank 0 worker and give that one extra work. For example, if you’re logging metrics in wandb, you don’t want each worker in a large job doing that, you want to just have a single worker responsible for that. Regardless of what compute topology you deploy on, you’ll always have a global rank 0 worker, so it’s a safe grab.\nIf you launch through torchrun or accelerate you can get that data through environmental variables.\nlocal_rank = int(os.environ[\"LOCAL_RANK\"]) global_rank = int(os.environ[\"RANK\"]) world_size = int(os.environ[\"WORLD_SIZE\"]) A full list of everything torchrun will populate in environmental variables can be found here.\nThose are your basics. Now, let’s write a simple data parallelism implementation.\nVanilla Data Parallelism Of course, for this to work, you need to be processing your micro-batches on exact replicas of the same model. Let’s write a simple wrapper that will handled vanilla distributed data parallelism for us.\nimport torch.distributed as dist class SimpleDistributedDataParallel: def __init__(self, model: torch.nn.Module): self.model = model self.sync_grads = False for param in self.model.parameters(): rank_0_param = param.data.clone() dist.broadcast(rank_0_param, src=0) self._sync_time = 0 self._sync_calls = 0 Broadcast ensures that every local worker is going to get the same initialized parameters as our rank 0 worker. So we’re off to a good start!\nThe next thing we need to do is make sure that each node gets different data to work with. This is trivialized thanks to datasets.distributed\ndevice = torch.device(f\"cuda:{local_rank}\") if torch.cuda.is_available() else torch.device(\"cpu\") tokenizer=get_tokenizer() tokenized_ds = get_tokenized_dataset(tokenizer=tokenizer) data_collator = DataCollatorForLanguageModeling(tokenizer=tokenizer, mlm=False) train_dataset = split_dataset_by_node( tokenized_ds, world_size=world_size, rank=local_rank ) def collate_func(batch): padded = tokenizer.pad( batch, padding=\"longest\", max_length=None, pad_to_multiple_of=8, return_tensors=\"pt\" ) padded['labels'] = padded['input_ids'].clone() return padded train_dataloader = DataLoader( train_dataset, batch_size=per_device_train_batch_size, collate_fn=collate_func, drop_last=True, shuffle=True ) Though it’s a fun exercise to implement yourself. From the documentation\nEach node is assigned a chunk of data, e.g. rank 0 is given the first chunk of the dataset. To maximize data loading throughput, chunks are made of contiguous data on disk if possible.\nSo from my entire dataset, each node is going to be assigned a certain number of samples from that dataset, and this will be invisible to me when I’m iterating through my dataloader.\nNow we’ve ensured that our replicas start in the same place and that when they process data it will be different data that gives us unique gradient information. Now we’ve got to be able to sync our gradients between workers before the optimizer step. In addition, we want to ensure that backwards() does not always sync gradients, because gradient accumulation means we may be calling backwards() several times before we’re actually ready to run the optimization step.\nAlso, I want to make sure we can measure the communication time for syncing the gradients. But that’ll be important later.\nclass SimpleDistributedDataParallel: def __init__(self, model: torch.nn.Module): self.model = model self.sync_grads = False for param in self.model.parameters(): dist.broadcast(param.data, src=0) self._sync_time = 0 self._sync_calls = 0 def sync_gradients(self): \"\"\" Call before optimizer step \"\"\" if not self.sync_grads: return t0 = time.perf_counter() for param in self.model.parameters(): if param.grad is not None: dist.all_reduce(param.grad, op=dist.ReduceOp.AVG) torch.cuda.synchronize() t1 = time.perf_counter() self._sync_time += t1 - t0 self._sync_calls += 1 @property def avg_sync_time(self): return self._sync_time / self._sync_calls if self._sync_calls \u003e 0 else 0 def __call__(self, *args, **kwargs): return self.model(*args, **kwargs) def disable_grad_sync(self): self.sync_grads = False def enable_grad_sync(self): self.sync_grads = True def train(self): self.model.train() def eval(self): self.model.eval() Mostly this is a wrapper around our model. Most of the api, like __call__, train and eval we want to keep the same.\nThe big thing here is sync_gradients. Once we’ve reached our desired number of gradient accumulation steps, we want to make sure the replicas have a shared understanding of the gradients before the optimizer step runs. To do that, we want to do an all-reduce, where the data is distributed between workers with some function applied to it. In our case, that’ll be averaging. At the end of the operation each replica will have the same understanding of the gradients.\nmodel.train() num_batches = 0 for (i, batch) in enumerate(train_dataloader): batch = {k: v.to(device) for k, v in batch.items()} if i \u003e 2048: break if (i + 1) % gradient_accumulation_steps == 0: dp_model.enable_grad_sync() else: dp_model.disable_grad_sync() output = dp_model(**batch) loss = output.loss / gradient_accumulation_steps output.loss.backward() if dp_model.sync_grads: dp_model.sync_gradients() optimizer.step() optimizer.zero_grad() if global_rank == 0: wandb.log({\"loss\": loss.item() * gradient_accumulation_steps, \"step\": i, \"avg_sync_time_seconds\": dp_model.avg_sync_time, \"perplexity\": torch.exp(loss).item()}) num_batches += 1 With that written up and some standard dataloader code written around it (which you can look at here if you’re interested) we’ve implemented a very basic data parallelism.\nSome profiling here:\nShocking: distributed nodes take longer.\nWe on average do the all-reduce comms in about 200ms. This is quite high for GPUs on the same node! But that mostly has to do with using our hand-rolled algorithm that doesn’t support bucketing.\nThe devil is here:\nfor param in self.model.parameters(): if param.grad is not None: dist.all_reduce(param.grad, op=dist.ReduceOp.AVG) We’re generating a lot of overhead. This is because for every single parameter, we’re calling an all-reduce. Each of these is separate, so there’s some overhead in setting up communications being done each and every time. Even if all the data is small it’s a lot to do. Instead, we could use a bucketing strategy. This breaks the data up into larger chunks, combining data of up to about ~25MB together. This reduces the total amount of communications that need to get done. You can see a good implementation of this over in picotron.\nWe won’t implement it here, because we’re interested in a different question. Let’s hold that operation constant, and instead play with how long it takes to perform as we pull these two workers further from each other.\nIf I run the exact same code but on two different nodes without Remote Direct Memory Access (RDMA) it runs in about ~500ms. Worse still, but tolerable.\nWe can keep extending that distance, just based on what we know about the internet. We’re transferring on the order of 18MB with each all-reduce here. On the same node, with PCIe we’ve got a bandwidth of around ~10-25 Gbps. Latency will be short. On different nodes we’ve got to kick on the network stack which increases our overhead (thus the 500ms). Not so bad.\nBut what if we don’t have nodes on the same rack? What if they’re not even in the same data center? What if we don’t have a data center, and are instead sourcing compute from wherever we can get it?\nPic related: the wherever we can get it\nIn this world, we may be pushing those 18MB over regular old internet bandwidth. That might take the all-reduce to ~20 seconds. This is all with a relatively small model, and that parameter count and the gradients that have to be moved can get quite a bit larger as you scale the size of your model and the number of machines that have to communicate.\nYou want to train a big model. You might even have the dollars to spend on spot-compute. But you’re data center poor and you want to do research with the big boys. What do you do?\nDiLoCo - Take What You Can Get So, our compute isn’t shared in a single data center, but rather plucked from discrete nodes and clusters located all over the continent - or the world. We want to do data parallelism to increase our effective batch size, but it seems very likely if we use our current approach GPUs will spend most of their time idling due to expensive and slow network operations.\nOur ideal technique would be one that’s stackable (in that it uses data parallelism but does not prevent using other parallelisms), comfortable with heterogenous compute (different nodes/clusters with different GPUs), capable of communicating infrequently across a large geographic distance. Since we’re GPU-poor and use spot instances, it would also save us a lot of gray hair if it was tolerant of nodes dropping out or joining partway through training.\nAs it turns out, that exists. It’s called DiLoCo: Distributed Low-Communication Training of Language Models.\nThe DiLoCo paper If you’ve done a brief read of HuggingFace’s The Ultra-Scale Playbook4, the DiLoCo paper is actually quite readable.\nThe basic setup mirrors data parallelism exactly. You’ve got replicas of your model, deployed to potentially heterogenous compute. Just like standard data parallelism, each replica also has its own discrete part of the dataset available for training.\nWhat’s different is that each replica also saves the initial state of the model before training begins, and each replica has two. That initial state of the model copy is offloaded onto CPU, since it won’t be used frequently. Onto the optimizers: the first is called the “inner optimizer”. It’s a very standard AdamW optimizer in the paper, but it’s whatever you would use for standard training. The inner optimizer loop is entirely normal, and does no communication between workers, and so does not incur any communication cost. You can add gradient accumulation as you like, whatever you need to get to an effective batch size you want for training.\nIn addition, training proceeds completely normally for a set amount of inner steps (let’s call it $H$). Training proceeds independently for all nodes. $H$ is a hyperparameter, but to be useful it’s set at something on the order of 500. That is, you’re calling optimizer.step() on the inner optimizer 500 times before any communication happens between these disparate hosts.\nSo essentially you’re training $n$ replicas of the model, one for each worker, starting from the same place and diverging as they update. How does this bubble up to a single trained model at the end?\nThe outer optimizer is responsible for that. Every $H$ steps, the outer optimizer loop happens. This is the tricky bit.\nThe outer optimization step collects psuedo-gradients by looking at the difference between the original weights it had the last time the outer optimizer was called. At the first step, this was be the pre-trained weights or the initial values of the weights. The psuedo gradients are initial_parameter - replica_parameter for each parameter in the neural network. These psuedo gradients are different for each worker, since they’ve all been trained on different data and have been trained independently for these 500-odd steps.\nAn all-reduce is called on this step, so each worker averages these psuedo-gradients before calling the outer optimization step.\nThis outer optimizer is attached to the same weights as the inner optimizer, so when outer_optimizer.step() is called, each replica of the weights will be updated from the initial values with the same psuedo-gradients. So the replicas have once again been synced. A new copy of these weights is now stored in CPU for the next outer optimizer step, and training continues.\nThe inner-optimizer is not reset, so while each replica has the same weights, their AdamW keeps its first and second moment estimates. This results in transient training spikes, but doesn’t cause a problem otherwise. Training continues until the desired amount of outer steps have been reached.\nIf this sounds miraculous and unlikely, it’s probably because of your intuition about AdamW. AdamW is not what the outer optimizer is using. The paper very specifically uses Nesterov.\nSpecifically, the paper says:\nWe hypothesize that the Nesterov’s gradient correction is particularly helpful with the outer gradient that span hundred of training steps.\nAn intuition about this is [intuition].\nThe paper ends with a series of ablations. What if compute joins or leaves during training? They find models end up generalizing well given a fixed compute budget, regardless of how that compute is made available over time. What if we do all of this on a single worker? Convergence speeds up. What if the communication is asynchronous and spotty, and outer gradient communications don’t always reach a given worker? No problem, let the worker continue training the model for another round of $H$ inner-states and try again, it only slightly effects the final perplexity of the model. In general, the paper concludes that DiLoCo is just a vary robust algorithm for data parallelism.\nThis isn’t pure research, either. Prime Intellect took it out on the road with Intellect-1. Prime Intellect’s training used their own DiLoCo implementation that supports FSDP2. DiLoCo is used across nodes and FSDP within nodes. The resulting 10B parameter model converged, training on 14 concurrent nodes on three different continents, across 30 different compute providers.\nA cool detail in the paper is that the all-reduce operation during the outer optimizer step took between one and seven minutes. This occurred after the inner optimization step roughly every 38 minutes. They chose $H$ to be a somewhat conservative 100 steps. This means that without DiLoCo, the all-reduce would’ve needed to be incurred for every one of those 100 steps. That would mean roughly every 23 seconds a lag of 1-7 minutes would’ve been introduced! Training would’ve been totally infeasible.\nNow that we’re sufficiently motivated to understand how cool it is, let’s implement a vanilla DiLoCo and see how it works.\nImplementation We’re going to create a wrapper the same way we did it for vanilla data parallelism, with some tweaks.\nclass Diloco: def __init__(self, model, inner_optimizer, outer_optimizer, warmup_steps, total_steps, inner_steps: int = 100, outer_steps: int = 10 ): self.model = model self.inner_optimizer = inner_optimizer self.outer_optimizer = outer_optimizer self.scheduler = get_cosine_schedule_with_warmup(self.inner_optimizer, num_warmup_steps=warmup_steps, num_training_steps=total_steps) for param in self.model.parameters(): dist.broadcast(param.data, src=0) self.offloaded_last_sync_parameters = self._get_offloaded_parameters() We’ll distribute our initial weights the same way, again. We’ll now need an inner_optimizer and an outer_optimizer, so we’ll grab both of those.\nAfter we’ve synced, we want to offload our starting state into self.offloaded_last_sync_parameters. This will always be the current state of the model. Our inner optimizers run on and modify our specific replica trained on their own data. When we’re ready for the outer step, we’ll need the most recent synced copy of the parameters. We offloaded these to CPU to avoid keeping another copy in GPU vram.\ndef _get_offloaded_parameters(self): return [ param.data.detach().clone().to(\"cpu\") for group in self.outer_optimizer.param_groups for param in group[\"params\"] ] What used to be just step on the replicas in data parallelism is now our inner_step. Our inner step doesn’t change very much. Though, this time I applied gradient clipping for smoother training, as well as a learning rate schedule since these are included in the paper.\ndef inner_step(self): torch.nn.utils.clip_grad_norm_(self.model.parameters(), max_norm=1.0) self.inner_optimizer.step() self.scheduler.step() self.inner_optimizer.zero_grad() The outer step is where things get properly interesting. Let’s look at the conditions that cause it to fire, and then look at the implementation itself.\n# ... normal train_dataloader setup for (i, batch) in enumerate(train_dataloader): real_step = (i + 1) // gradient_accumulation_steps batch = {k: v.to(device) for k, v in batch.items()} output = diloco_model(**batch) loss = output.loss / gradient_accumulation_steps output.loss.backward() if (i + 1) % gradient_accumulation_steps == 0: diloco_model.inner_step() if real_step % inner_steps == 0: diloco_model.outer_step() So we still have our gradient accumulation steps for the inner optimizer, and only called inner_step when we’ve accumulated enough gradients to hit the batch size we’re interested in.\nAfter we’ve called our inner step, we check to see whether we’ve hit the proper number of inner_steps. This is the $H$ we discussed above. If we have, it’s time to call the outer step.\ndef outer_step(self) -\u003e None: \"\"\" Outer step for Diloco. Loads last sync parameters from CPU to GPU and computes the psuedo-gradient for outer optimizer. Updates the offloaded parameters to CPU. \"\"\" replica_params = [ param for group in self.inner_optimizer.param_groups for param in group[\"params\"] ] for replica_param, last_sync_param in zip(replica_params, self.offloaded_last_sync_parameters): last_sync_param_on_device = last_sync_param.to(replica_param.device) replica_param.grad = last_sync_param_on_device - replica_param.data dist.all_reduce(tensor=replica_param.grad, op=dist.ReduceOp.AVG) replica_param.data = last_sync_param_on_device self.outer_optimizer.step() self.outer_optimizer.zero_grad() self.offloaded_last_sync_parameters = self._get_offloaded_parameters() First we get our current replica parameters so they can be zipped against our last synced ones. replica_param is the current state of the model that’s already loaded into GPU memory we’ve been optimizing.\nFirst, briefly, we read the offloaded parameters into GPU memory. At this point, there aren’t any activations being computed, so the storing the additional model on device briefly isn’t super painful. Then, you set the recently zeroed gradient of the on device model to the difference between the last sync, and the replicas current understanding of the world. This distance becomes the psuedo gradient. Then, you perform an all-reduce, so the gradients now represent the average distance between the last synced model and its replicas. Finally, you place the last synced model parameter data over the replicas weights.\nSo very briefly, you overwrite all of your progress. The models are right back to their starting state! But crucially, they’re back to their starting state with our psuedo-gradient information. All that’s left to do is take your step. As soon as that step occurs on each replica, the models have made a large update with information from the training they each did independently. Finally, you overwrite the last sync parameters by offloading the new weights you’ve computed into CPU for the next step, and continue training as normal.\nResults It runs!\nIf you want to try this for yourself, you can check out my repo here for NanoDiloco. The wandb logs are here. If you want to see what production grade DiLoCo looks like, Prime Intellect has a beautiful repo for it here.\nAnd to Zach, who I hope reads this: great class! I’ve found in general it’s easy to find teachers if the thing you want to learn is ~5 years out of date, but the closer you get to the cutting edge the rarer it is to find someone who is both gifted at doing the work itself as well as concisely communicating that understanding to other people, pulling all the pedagogical knobs and levers required.\n“Look at the crummy latency on this model, look at the dumb mistakes it makes, and how limited its labels are! We could never go to prod with this. Now, let’s talk about our labeling budget…” ↩︎\nThat age-old ill. Eventually I will be old enough where I stop doing it. ↩︎\nOr just placing your faith in Unsloth and riding that single GPU as far as it’ll go ↩︎\nAnd if you haven’t, you should! It’s an excellent introduction to different parallelism strategies necessary for training modern models. ↩︎\n","wordCount":"5275","inLanguage":"en","image":"http://localhost:1313/","datePublished":"2025-10-03T00:00:00Z","dateModified":"2025-10-03T00:00:00Z","author":{"@type":"Person","name":"Shane Caldwell"},"mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:1313/writing/data-parallelism-for-the-poor/"},"publisher":{"@type":"Organization","name":"Shane Caldwell","logo":{"@type":"ImageObject","url":"http://localhost:1313/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=http://localhost:1313/ accesskey=h title="Shane Caldwell (Alt + H)">Shane Caldwell</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=http://localhost:1313/ title=Main><span>Main</span></a></li><li><a href=http://localhost:1313/papers/ title=Papers><span>Papers</span></a></li><li><a href=http://localhost:1313/talks/ title=Talks><span>Talks</span></a></li><li><a href=http://localhost:1313/writing/ title=Writing><span>Writing</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">DiLoCo: Data Parallelism for the Datacenter Poor</h1><div class=post-description>Distributed training sans datacenter.</div><div class=post-meta><span title='2025-10-03 00:00:00 +0000 UTC'>October 3, 2025</span>&nbsp;·&nbsp;25 min&nbsp;·&nbsp;5275 words&nbsp;·&nbsp;Shane Caldwell</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#gradient-accumulation>Gradient Accumulation</a></li><li><a href=#data-parallelism>Data Parallelism</a></li><li><a href=#a-brief-interlude-on-distributed-torch>A Brief Interlude On Distributed Torch</a></li><li><a href=#vanilla-data-parallelism>Vanilla Data Parallelism</a></li><li><a href=#diloco---take-what-you-can-get>DiLoCo - Take What You Can Get</a></li><li><a href=#the-diloco-paper>The DiLoCo paper</a></li><li><a href=#implementation>Implementation</a></li><li><a href=#results>Results</a></li></ul></nav></div></details></div><div class=post-content><p>I&rsquo;m a big believer in private models. I always have been. The term &ldquo;local&rdquo; model still strikes me as strange, because it was previously the default. We&rsquo;d just call them <em>models</em>. If we had to refer to a third party hosted model, we&rsquo;d just say &ldquo;the default google model&rdquo; or whatever, and that was generally derogatory.</p><p>Part of this is just when I started in the field. I became an ML engineer in 2018, and finetuning or training models from scratch was just <em>what you did</em>. There were a few API-based models you could call, but outside of sentiment analysis they were nearly all uniformly very bad. My friends and I mostly used them as evidence to our boss that we needed to invest more budget in training<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup>.</p><p>Another part of this is a sort of functional professional paranoia. If I put out a product, I&rsquo;m in some sense responsible for its reliability. If you&rsquo;re an API wrapper, there&rsquo;s very little guarantees you can make. Will my performance be consistent? Will the model be up? Will I wake up one day to find the model is deprecated? I have no idea, man, I just call the API and hope for the best. There are benefits to this, sure, your product can just <em>get better</em> with no effort on your part, but it can also just <em>get worse</em> or <em>stop existing</em>.</p><p>Finally, and most important to me if I&rsquo;m being honest, it&rsquo;s a professional pride thing. I&rsquo;m a scientist and an engineer, and for the largest part of my career my responsibility has been making models. You want some weights that do a thing, I go through the effort of collecting data, training a model, iterating on it, serving it, improving it. It feels really good to do. You end up being SOTA at some insanely domain-specific stuff. For several years I worked primarily on object detection for household objects for a moving company. The amount of mental energy I spent on data augmentation for occlusion would boggle your mind. To go through that effort and see it work gives you an insane amount of dopamine. Calling an API, frankly, doesn&rsquo;t hit the same.</p><p>So, to reduce the probability of calling APIs for the rest of my life, it&rsquo;s time to hit the books.</p><h1 id=hitting-the-books>Hitting the Books<a hidden class=anchor aria-hidden=true href=#hitting-the-books>#</a></h1><p>The goal is to competently train competitively performant LLMs. I&rsquo;ve done quite a bit of finetuning of smaller models. Take an A100 and a small Qwen or Llama, finetune it for some particular task, or do a little GRPO. But to train something larger (>30B) and on longer context lengths (128k), I need some skillsets I don&rsquo;t have. In-particular, distributed training.</p><p>Over the past eight years I&rsquo;ve been in the field, multi-gpu and multi-node training has gone from a nice-to-have to necessity. Working in computer vision, I might be finetuning a YOLOv8 model that had, on the upper end, around 50M parameters. Running out of GPU memory wasn&rsquo;t a significant concern of mine. When I had access to multiple GPUs, my primary dimension of parallelization was running different training jobs on each GPU in order to speed up hyper-parameter sweep. It&rsquo;s likely I could have trained slightly faster if I had invested time in becoming comfortable with the torch profiler, but it just wasn&rsquo;t a showstopper. The compute was relatively cheap. In general, I found it was much more productive to spend time looking at the data, collecting more data, and introducing new data augmentations. I only looked into serious performance improvements for models when I was putting them on mobile, and that could mostly be done with some kernel fusion and futzing with <code>torch.compile</code>. High performance distributed training just wasn&rsquo;t a muscle I stretched very often.</p><p>Necessity, however, is the mother of getting-your-act-together.</p><p>I bounced off <a href=https://huggingface.co/spaces/nanotron/ultrascale-playbook>The Ultra-Scale Playbook</a> a few times. Mostly just because I was reading it and not applying it<sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup>. The concepts are all there, the exercises are more choose-your-own-adventure. The correct course of action was to just pick something and work on it, but when you&rsquo;re <a href=https://dreadnode.io/>busy</a> it helps if you&rsquo;ve got a little bit of handholding and lot of forcing function. Thankfully, I got the forcing function I was looking for with <a href=https://maven.com/walk-with-code/scratch-to-scale>Scratch to Scale</a> from <a href=https://x.com/TheZachMueller>Zach Mueller</a>, a class on taking the many distributed techniques necessary for making large model training practical and making you implement them. In addition, he had a totally insane set of lecturers from Unsloth, Prime Intellect, Ray, Huggingface, etc, each of whom is world-class at their particular part of the stack.</p><p>I&rsquo;m not an online class person. I hate my schedule being dictated by someone else. I&rsquo;ve got a job for that! But the syllabus looked like exactly what I was looking for, and it was. Zach&rsquo;s a great lecturer and everything I kinda-sorta &ldquo;knew&rdquo; from reading about parallelism techniques from different places is now in my bones from working on those implementations. I&rsquo;m confident it will help me out a ton on my main research focus: training really competent, really small judges for post-training. Thanks Zach! I&rsquo;ll be back for that post-training class.</p><p>Speaking of implementations I&rsquo;ve gotten cozy with, let&rsquo;s talk about the simplest and most vanilla of the parallelisms: data parallelism. Then we can talk about how to make it work if you happen to have misplaced your datacenter (DiLoCo).</p><h1 id=why-scale>Why Scale?<a hidden class=anchor aria-hidden=true href=#why-scale>#</a></h1><p>We&rsquo;ll start with some assumptions. First, let&rsquo;s assume you&rsquo;re interested in pre-training. Lots of models on a large batch size. Second, let&rsquo;s assume that the model you want to train fits entirely in GPU memory, for at least one batch during training and that model is going to be trained in full precision (FP32). Let&rsquo;s go over what is going to need to fit into memory. Before we even start talking about activations, let&rsquo;s go over parameters, gradients, and optimizer states. We&rsquo;ll calculate all this in terms of bytes.</p><p>First,</p>$$m_{params} = 4 * N$$<p>Each parameter is four bytes (32 bit precision). So if you&rsquo;re training a 7B parameter model, you&rsquo;ve got $4 * (7*10^9)$. There are $10^9$ bytes in a gigabyte, that&rsquo;s 24GB right there.</p><p>Next, you&rsquo;ve got,</p>$$m_{grad} = 4 * N$$<p>You&rsquo;ve got FP32 gradients for each parameter in the model during the backward pass. That&rsquo;s another 24GB of memory.</p><p>Finally, you&rsquo;ve got:</p>$$m_{opt}= (4 + 4) * N$$<p>This won&rsquo;t be the same for all optimizers. But let&rsquo;s say we&rsquo;re using standard <a href=https://docs.pytorch.org/docs/stable/generated/torch.optim.Adam.html>Adam</a>. Adam is going to store the momentum and variance in FP32 for each parameter. So that&rsquo;s an additional 48GB of memory.</p><p>So, assuming we&rsquo;re using FP32, we&rsquo;re at 96GB already, before we&rsquo;ve even computed an activation. All that for a measly 7B parameter model. No wonder people feel GPU poor.</p><p>So 7B was ambitious for fitting on a single card. I just wanted to write it out because 7B is chump change and already has you reaching for different techniques to distribute memory over multiple cards/nodes<sup id=fnref:3><a href=#fn:3 class=footnote-ref role=doc-noteref>3</a></sup>. For the purposes of this post, let&rsquo;s assume our model is smaller. Call it a ~1B parameter model. Those same calculations would give us 2GB for model parameters, 2GB for gradients, and 4GB for optimizers. A healthy 8GB that would fit on most consumer grade cards. It&rsquo;s also the size of <a href=https://huggingface.co/openai-community/gpt2-xl>GPT-2 XL</a>, so you&rsquo;re at least in the 2019 tech tree.</p><p>Now let&rsquo;s pick a target batch size. Our target-batch size should be at the <em>token</em> level. OpenAI&rsquo;s <a href=https://arxiv.org/pdf/2005.14165>Language Models are Few-Shot Learners</a> gives us as good a place as any to start for our humble 1(.3)B parameter model.</p><figure><img loading=lazy src=gpt-3-params.png alt="On Teslas is crazy"><figcaption><p>On Teslas is crazy</p></figcaption></figure><p>A batch size of 1 million tokens. If our dataset has 1024 tokens in each sample, that means we&rsquo;d want roughly:</p>$$\text{Number of samples} = \left\lfloor \frac{\text{Total tokens in batch}}{\text{Tokens per sequence}} \right\rfloor = \left\lfloor \frac{1 \times 10^6}{1024} \right\rfloor \approx 976$$<p>976 samples! Intuitively you probably understand that&rsquo;s not going to fit in your forward pass. But exactly how much is it <em>not</em> going to fit in your forward pass? To really grok this we&rsquo;re going to need to consider activation memory, which we&rsquo;ve been avoiding because it&rsquo;s slightly more complicated, and it&rsquo;s going to stick around through the backward pass.</p><p>The Ultrascale playbook lists it, for mixed precision with each element requiring two bytes of storage:</p>$$m_{act} = L\cdot seq \cdot bs \cdot h \cdot (34 + \dfrac{5 \cdot n_{heads} \cdot seq}{h})$$<p>$L$ is the number of layers, $seq$ is sequence length, $bs$ is batch size per sample, and $h$ is the hidden dimension of the model, $n_{heads}$ is the number of heads.</p><p>We can simply double this in order to get to FP32. Already you can see the result is going to be quadratic with respect to sequence length, which will dominate here. Let&rsquo;s go ahead and fill out these values.</p>$$\begin{align}
L &= 48 \text{ (n\_layer)} \\
seq &= 1024 \text{ (n\_ctx)} \\
bs &= 976 \text{ (your batch size)} \\
h &= 1600 \text{ (n\_embd)} \\
n_{heads} &= 25 \text{ (n\_head)} \\
\\
m_{act} &= L \cdot seq \cdot bs \cdot h \cdot \left(34 + \frac{5 \cdot n_{heads} \cdot seq}{h}\right) \\
\\
&= 48 \times 1024 \times 976 \times 1600 \times \left(34 + \frac{5 \times 25 \times 1024}{1600}\right) \\
\\
&= 48 \times 1024 \times 976 \times 1600 \times \left(34 + \frac{128,000}{1600}\right) \\
\\
&= 48 \times 1024 \times 976 \times 1600 \times (34 + 80) \\
\\
&= 48 \times 1024 \times 976 \times 1600 \times 114 \\
\\
&= 8,765,317,734,400 \text{ elements} \\
&\approx 8.77 \times 10^{12} \text{ elements}
\end{align}$$<p>Multiply by two to get into FP32, and you&rsquo;re looking at $17.5 \cdot 10^{12}$ bytes. That ends up being 17,500 GB of VRAM for a forward pass, or roughly 17.5 terabytes of VRAM. That&rsquo;s not gonna work on a single forward pass on a single card. Not on your 4090, not on an A100, not on an H100.</p><p>All that, mind you, as pre-training for a <em>1.5</em>B parameter model. They go north of a trillion in parameter count, on sequences <em>much</em> longer than 1024 elements. So we&rsquo;ll need some tricks. We&rsquo;ll talk about two now: gradient accumulation and data parallelism.</p><h2 id=gradient-accumulation>Gradient Accumulation<a hidden class=anchor aria-hidden=true href=#gradient-accumulation>#</a></h2><p>The elites don&rsquo;t want you to know you don&rsquo;t have to called <code>optimizer.step()</code> immediately after <code>loss.backwards()</code>. You can do it whenever you feel like it!</p><p>If you&rsquo;ve got a target batch size on a particular GPU but the activations are too large to send all of them in one go, you can break them up into <em>micro</em>-batches. Say you can only fit two samples in the forward/backward pass, but you want a batch size of eight. You can Just break up four micro-batches, successively running the forward and backward passes. Finally you can average the gradients and perform the optimizer step.</p><p>So your <em>real</em> batch size now looks like:</p>$$batch\space size = micro\space batch \space size \times gradient\space accumulation\space steps $$<p>So in principle, as long as you can do a forward/backward pass with at least one sample, you can increase your batch size to whatever you please while holding the memory footprint constant on our single GPU. In our example, you could run the forward/backward pass 976 times to get to the token batch size you were looking for. In principle, you could train GPT-2XL on a single consumer card!</p><p>In reality, needing to perform 976 forward/backward passes before your optimizer step is throwing some serious compute overhead down, and your wall clock time will be in terms of years. So - you could do it, but it&rsquo;s not what serious people do. And we&rsquo;re <em>very serious</em> people. What else do we have?</p><p>More GPUs.</p><h2 id=data-parallelism>Data Parallelism<a hidden class=anchor aria-hidden=true href=#data-parallelism>#</a></h2><p>Data parallelism is ultimately about increasing your effective batch size, similar to gradient accumulation, just with more parallel FLOPs.</p><p>The basic idea is that we will replicate our model (which fits on a single card, remember!) onto multiple cards. Those cards could be on the same node, or cards on nodes in the same data center. If we keep the gradient accumulation steps we had before, our effective global batch size will be multiplied by the number of replicas.</p>$$batch\space size = num\space replicas \times micro\space batch \space size \times gradient\space accumulation\space steps $$<p>If you&rsquo;ve got a target batch size, then this is a recipe for reaching it. Find out what your maximum micro batch size is, decide how many GPUs you have access to, and then fill in the gaps with gradient accumulation.</p><h2 id=a-brief-interlude-on-distributed-torch>A Brief Interlude On Distributed Torch<a hidden class=anchor aria-hidden=true href=#a-brief-interlude-on-distributed-torch>#</a></h2><p>Before we get started, a few definitions you&rsquo;ll need to know as we go through code when we&rsquo;re talking about distributed training. You&rsquo;ve got some arbitrary number of workers that you&rsquo;d like your code to be essentially independent of. This model is called Single Program Multiple Data (SPMD). The same program is running on multiple workers with different data, and each executes independently within their own interpreters, communicating when they need to. Terms it&rsquo;ll be helpful to know follow:</p><p><strong>World Size</strong>: This refers to the total number of processes/GPUs. So if you fired up two nodes with four GPUs a piece, the world size is 8. They are, however, zero-indexed.</p><p><strong>Local Rank</strong>: This refers to the rank within a single node. That will go from 0 to the number of gpus per node, minus one. So if you have four gpus per box, that&rsquo;s 0-3.</p><p><strong>Rank</strong>: This is the global rank from 0 to world size minus one. That is, 0 to 7 in this case.</p><p>Since you&rsquo;re shipping the same program to multiple workers, a common pattern you&rsquo;ll see reading distributed torch code is a conditional to check if you&rsquo;re the rank 0 worker and give that one extra work. For example, if you&rsquo;re logging metrics in wandb, you don&rsquo;t want each worker in a large job doing that, you want to just have a single worker responsible for that. Regardless of what compute topology you deploy on, you&rsquo;ll always have a global rank 0 worker, so it&rsquo;s a safe grab.</p><p>If you launch through <code>torchrun</code> or <code>accelerate</code> you can get that data through environmental variables.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>local_rank</span> <span class=o>=</span> <span class=nb>int</span><span class=p>(</span><span class=n>os</span><span class=o>.</span><span class=n>environ</span><span class=p>[</span><span class=s2>&#34;LOCAL_RANK&#34;</span><span class=p>])</span>
</span></span><span class=line><span class=cl><span class=n>global_rank</span> <span class=o>=</span> <span class=nb>int</span><span class=p>(</span><span class=n>os</span><span class=o>.</span><span class=n>environ</span><span class=p>[</span><span class=s2>&#34;RANK&#34;</span><span class=p>])</span>
</span></span><span class=line><span class=cl><span class=n>world_size</span> <span class=o>=</span> <span class=nb>int</span><span class=p>(</span><span class=n>os</span><span class=o>.</span><span class=n>environ</span><span class=p>[</span><span class=s2>&#34;WORLD_SIZE&#34;</span><span class=p>])</span>
</span></span></code></pre></div><p>A full list of everything torchrun will populate in environmental variables can be found <a href=https://docs.pytorch.org/docs/stable/elastic/run.html#environment-variables>here</a>.</p><p>Those are your basics. Now, let&rsquo;s write a simple data parallelism implementation.</p><h2 id=vanilla-data-parallelism>Vanilla Data Parallelism<a hidden class=anchor aria-hidden=true href=#vanilla-data-parallelism>#</a></h2><p>Of course, for this to work, you need to be processing your micro-batches on exact replicas of the same model. Let&rsquo;s write a simple wrapper that will handled vanilla distributed data parallelism for us.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>import</span> <span class=nn>torch.distributed</span> <span class=k>as</span> <span class=nn>dist</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>SimpleDistributedDataParallel</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>model</span><span class=p>:</span> <span class=n>torch</span><span class=o>.</span><span class=n>nn</span><span class=o>.</span><span class=n>Module</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>model</span> <span class=o>=</span> <span class=n>model</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>sync_grads</span> <span class=o>=</span> <span class=kc>False</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>param</span> <span class=ow>in</span> <span class=bp>self</span><span class=o>.</span><span class=n>model</span><span class=o>.</span><span class=n>parameters</span><span class=p>():</span>
</span></span><span class=line><span class=cl>            <span class=n>rank_0_param</span> <span class=o>=</span> <span class=n>param</span><span class=o>.</span><span class=n>data</span><span class=o>.</span><span class=n>clone</span><span class=p>()</span>
</span></span><span class=line><span class=cl>            <span class=n>dist</span><span class=o>.</span><span class=n>broadcast</span><span class=p>(</span><span class=n>rank_0_param</span><span class=p>,</span> <span class=n>src</span><span class=o>=</span><span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>_sync_time</span> <span class=o>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>_sync_calls</span> <span class=o>=</span> <span class=mi>0</span>
</span></span></code></pre></div><p>Broadcast ensures that every local worker is going to get the same initialized parameters as our rank 0 worker. So we&rsquo;re off to a good start!</p><p>The next thing we need to do is make sure that each node gets different data to work with. This is trivialized thanks to <code>datasets.distributed</code></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl>    <span class=n>device</span> <span class=o>=</span> <span class=n>torch</span><span class=o>.</span><span class=n>device</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;cuda:</span><span class=si>{</span><span class=n>local_rank</span><span class=si>}</span><span class=s2>&#34;</span><span class=p>)</span> <span class=k>if</span> <span class=n>torch</span><span class=o>.</span><span class=n>cuda</span><span class=o>.</span><span class=n>is_available</span><span class=p>()</span> <span class=k>else</span> <span class=n>torch</span><span class=o>.</span><span class=n>device</span><span class=p>(</span><span class=s2>&#34;cpu&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>tokenizer</span><span class=o>=</span><span class=n>get_tokenizer</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=n>tokenized_ds</span> <span class=o>=</span> <span class=n>get_tokenized_dataset</span><span class=p>(</span><span class=n>tokenizer</span><span class=o>=</span><span class=n>tokenizer</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>data_collator</span> <span class=o>=</span> <span class=n>DataCollatorForLanguageModeling</span><span class=p>(</span><span class=n>tokenizer</span><span class=o>=</span><span class=n>tokenizer</span><span class=p>,</span> <span class=n>mlm</span><span class=o>=</span><span class=kc>False</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>train_dataset</span> <span class=o>=</span> <span class=n>split_dataset_by_node</span><span class=p>(</span>
</span></span><span class=line><span class=cl>        <span class=n>tokenized_ds</span><span class=p>,</span> <span class=n>world_size</span><span class=o>=</span><span class=n>world_size</span><span class=p>,</span> <span class=n>rank</span><span class=o>=</span><span class=n>local_rank</span>
</span></span><span class=line><span class=cl>    <span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>collate_func</span><span class=p>(</span><span class=n>batch</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=n>padded</span> <span class=o>=</span> <span class=n>tokenizer</span><span class=o>.</span><span class=n>pad</span><span class=p>(</span>
</span></span><span class=line><span class=cl>            <span class=n>batch</span><span class=p>,</span>
</span></span><span class=line><span class=cl>            <span class=n>padding</span><span class=o>=</span><span class=s2>&#34;longest&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>            <span class=n>max_length</span><span class=o>=</span><span class=kc>None</span><span class=p>,</span>
</span></span><span class=line><span class=cl>            <span class=n>pad_to_multiple_of</span><span class=o>=</span><span class=mi>8</span><span class=p>,</span>
</span></span><span class=line><span class=cl>            <span class=n>return_tensors</span><span class=o>=</span><span class=s2>&#34;pt&#34;</span>
</span></span><span class=line><span class=cl>        <span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>padded</span><span class=p>[</span><span class=s1>&#39;labels&#39;</span><span class=p>]</span> <span class=o>=</span> <span class=n>padded</span><span class=p>[</span><span class=s1>&#39;input_ids&#39;</span><span class=p>]</span><span class=o>.</span><span class=n>clone</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>padded</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>train_dataloader</span> <span class=o>=</span> <span class=n>DataLoader</span><span class=p>(</span>
</span></span><span class=line><span class=cl>        <span class=n>train_dataset</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=n>batch_size</span><span class=o>=</span><span class=n>per_device_train_batch_size</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=n>collate_fn</span><span class=o>=</span><span class=n>collate_func</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=n>drop_last</span><span class=o>=</span><span class=kc>True</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=n>shuffle</span><span class=o>=</span><span class=kc>True</span>
</span></span><span class=line><span class=cl>    <span class=p>)</span>
</span></span></code></pre></div><p>Though it&rsquo;s a fun exercise to implement yourself. From the <a href=https://huggingface.co/docs/datasets/en/package_reference/main_classes>documentation</a></p><blockquote><p>Each node is assigned a chunk of data, e.g. rank 0 is given the first chunk of the dataset. To maximize data loading throughput, chunks are made of contiguous data on disk if possible.</p></blockquote><p>So from my entire dataset, each node is going to be assigned a certain number of samples from that dataset, and this will be invisible to me when I&rsquo;m iterating through my dataloader.</p><p>Now we&rsquo;ve ensured that our replicas <em>start</em> in the same place and that when they process data it will be different data that gives us unique gradient information. Now we&rsquo;ve got to be able to sync our gradients between workers before the optimizer step. In addition, we want to ensure that <code>backwards()</code> does not <em>always</em> sync gradients, because gradient accumulation means we may be calling <code>backwards()</code> several times before we&rsquo;re actually ready to run the optimization step.</p><p>Also, I want to make sure we can measure the communication time for syncing the gradients. But that&rsquo;ll be important later.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>class</span> <span class=nc>SimpleDistributedDataParallel</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>model</span><span class=p>:</span> <span class=n>torch</span><span class=o>.</span><span class=n>nn</span><span class=o>.</span><span class=n>Module</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>model</span> <span class=o>=</span> <span class=n>model</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>sync_grads</span> <span class=o>=</span> <span class=kc>False</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>param</span> <span class=ow>in</span> <span class=bp>self</span><span class=o>.</span><span class=n>model</span><span class=o>.</span><span class=n>parameters</span><span class=p>():</span>
</span></span><span class=line><span class=cl>            <span class=n>dist</span><span class=o>.</span><span class=n>broadcast</span><span class=p>(</span><span class=n>param</span><span class=o>.</span><span class=n>data</span><span class=p>,</span> <span class=n>src</span><span class=o>=</span><span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>_sync_time</span> <span class=o>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>_sync_calls</span> <span class=o>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>sync_gradients</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=s2>&#34;&#34;&#34;
</span></span></span><span class=line><span class=cl><span class=s2>        Call before optimizer step
</span></span></span><span class=line><span class=cl><span class=s2>        &#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=ow>not</span> <span class=bp>self</span><span class=o>.</span><span class=n>sync_grads</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span>
</span></span><span class=line><span class=cl>        <span class=n>t0</span> <span class=o>=</span> <span class=n>time</span><span class=o>.</span><span class=n>perf_counter</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>param</span> <span class=ow>in</span> <span class=bp>self</span><span class=o>.</span><span class=n>model</span><span class=o>.</span><span class=n>parameters</span><span class=p>():</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=n>param</span><span class=o>.</span><span class=n>grad</span> <span class=ow>is</span> <span class=ow>not</span> <span class=kc>None</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=n>dist</span><span class=o>.</span><span class=n>all_reduce</span><span class=p>(</span><span class=n>param</span><span class=o>.</span><span class=n>grad</span><span class=p>,</span> <span class=n>op</span><span class=o>=</span><span class=n>dist</span><span class=o>.</span><span class=n>ReduceOp</span><span class=o>.</span><span class=n>AVG</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>torch</span><span class=o>.</span><span class=n>cuda</span><span class=o>.</span><span class=n>synchronize</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        <span class=n>t1</span> <span class=o>=</span> <span class=n>time</span><span class=o>.</span><span class=n>perf_counter</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>_sync_time</span> <span class=o>+=</span> <span class=n>t1</span> <span class=o>-</span> <span class=n>t0</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>_sync_calls</span> <span class=o>+=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>    <span class=nd>@property</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>avg_sync_time</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=bp>self</span><span class=o>.</span><span class=n>_sync_time</span> <span class=o>/</span> <span class=bp>self</span><span class=o>.</span><span class=n>_sync_calls</span> <span class=k>if</span> <span class=bp>self</span><span class=o>.</span><span class=n>_sync_calls</span> <span class=o>&gt;</span> <span class=mi>0</span> <span class=k>else</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=fm>__call__</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=o>*</span><span class=n>args</span><span class=p>,</span> <span class=o>**</span><span class=n>kwargs</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=bp>self</span><span class=o>.</span><span class=n>model</span><span class=p>(</span><span class=o>*</span><span class=n>args</span><span class=p>,</span> <span class=o>**</span><span class=n>kwargs</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>disable_grad_sync</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>sync_grads</span> <span class=o>=</span> <span class=kc>False</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>enable_grad_sync</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>sync_grads</span> <span class=o>=</span> <span class=kc>True</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>train</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>model</span><span class=o>.</span><span class=n>train</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>eval</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>model</span><span class=o>.</span><span class=n>eval</span><span class=p>()</span>
</span></span></code></pre></div><p>Mostly this is a wrapper around our model. Most of the api, like <code>__call__</code>, <code>train</code> and <code>eval</code> we want to keep the same.</p><p>The big thing here is <code>sync_gradients</code>. Once we&rsquo;ve reached our desired number of gradient accumulation steps, we want to make sure the replicas have a shared understanding of the gradients before the optimizer step runs. To do that, we want to do an all-reduce, where the data is distributed between workers with some function applied to it. In our case, that&rsquo;ll be averaging. At the end of the operation each replica will have the same understanding of the gradients.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>model</span><span class=o>.</span><span class=n>train</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=n>num_batches</span> <span class=o>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl><span class=k>for</span> <span class=p>(</span><span class=n>i</span><span class=p>,</span> <span class=n>batch</span><span class=p>)</span> <span class=ow>in</span> <span class=nb>enumerate</span><span class=p>(</span><span class=n>train_dataloader</span><span class=p>):</span>
</span></span><span class=line><span class=cl>	<span class=n>batch</span> <span class=o>=</span> <span class=p>{</span><span class=n>k</span><span class=p>:</span> <span class=n>v</span><span class=o>.</span><span class=n>to</span><span class=p>(</span><span class=n>device</span><span class=p>)</span> <span class=k>for</span> <span class=n>k</span><span class=p>,</span> <span class=n>v</span> <span class=ow>in</span> <span class=n>batch</span><span class=o>.</span><span class=n>items</span><span class=p>()}</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=n>i</span> <span class=o>&gt;</span> <span class=mi>2048</span><span class=p>:</span>
</span></span><span class=line><span class=cl>		<span class=k>break</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=p>(</span><span class=n>i</span> <span class=o>+</span> <span class=mi>1</span><span class=p>)</span> <span class=o>%</span> <span class=n>gradient_accumulation_steps</span> <span class=o>==</span> <span class=mi>0</span><span class=p>:</span>
</span></span><span class=line><span class=cl>		<span class=n>dp_model</span><span class=o>.</span><span class=n>enable_grad_sync</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>		<span class=n>dp_model</span><span class=o>.</span><span class=n>disable_grad_sync</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=n>output</span> <span class=o>=</span> <span class=n>dp_model</span><span class=p>(</span><span class=o>**</span><span class=n>batch</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=n>loss</span> <span class=o>=</span> <span class=n>output</span><span class=o>.</span><span class=n>loss</span> <span class=o>/</span> <span class=n>gradient_accumulation_steps</span>
</span></span><span class=line><span class=cl>	<span class=n>output</span><span class=o>.</span><span class=n>loss</span><span class=o>.</span><span class=n>backward</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=n>dp_model</span><span class=o>.</span><span class=n>sync_grads</span><span class=p>:</span>
</span></span><span class=line><span class=cl>		<span class=n>dp_model</span><span class=o>.</span><span class=n>sync_gradients</span><span class=p>()</span>
</span></span><span class=line><span class=cl>		<span class=n>optimizer</span><span class=o>.</span><span class=n>step</span><span class=p>()</span>
</span></span><span class=line><span class=cl>		<span class=n>optimizer</span><span class=o>.</span><span class=n>zero_grad</span><span class=p>()</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=n>global_rank</span> <span class=o>==</span> <span class=mi>0</span><span class=p>:</span>
</span></span><span class=line><span class=cl>			<span class=n>wandb</span><span class=o>.</span><span class=n>log</span><span class=p>({</span><span class=s2>&#34;loss&#34;</span><span class=p>:</span> <span class=n>loss</span><span class=o>.</span><span class=n>item</span><span class=p>()</span> <span class=o>*</span> <span class=n>gradient_accumulation_steps</span><span class=p>,</span> <span class=s2>&#34;step&#34;</span><span class=p>:</span> <span class=n>i</span><span class=p>,</span> <span class=s2>&#34;avg_sync_time_seconds&#34;</span><span class=p>:</span> <span class=n>dp_model</span><span class=o>.</span><span class=n>avg_sync_time</span><span class=p>,</span> <span class=s2>&#34;perplexity&#34;</span><span class=p>:</span> <span class=n>torch</span><span class=o>.</span><span class=n>exp</span><span class=p>(</span><span class=n>loss</span><span class=p>)</span><span class=o>.</span><span class=n>item</span><span class=p>()})</span>
</span></span><span class=line><span class=cl>			<span class=n>num_batches</span> <span class=o>+=</span> <span class=mi>1</span>
</span></span></code></pre></div><p>With that written up and some standard dataloader code written around it (which you can look at <a href=https://github.com/SJCaldwell/naive-data-parallel/blob/main/sillydp/main.py>here</a> if you&rsquo;re interested) we&rsquo;ve implemented a very basic data parallelism.</p><p>Some profiling here:</p><figure><img loading=lazy src=vanilla_avg_sync_in_seconds.png alt="Shocking: distributed nodes take longer."><figcaption><p>Shocking: distributed nodes take longer.</p></figcaption></figure><p>We on average do the all-reduce comms in about 200ms. This is quite high for GPUs on the same node! But that mostly has to do with using our hand-rolled algorithm that doesn&rsquo;t support bucketing.</p><p>The devil is here:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>for</span> <span class=n>param</span> <span class=ow>in</span> <span class=bp>self</span><span class=o>.</span><span class=n>model</span><span class=o>.</span><span class=n>parameters</span><span class=p>():</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=n>param</span><span class=o>.</span><span class=n>grad</span> <span class=ow>is</span> <span class=ow>not</span> <span class=kc>None</span><span class=p>:</span>
</span></span><span class=line><span class=cl>		<span class=n>dist</span><span class=o>.</span><span class=n>all_reduce</span><span class=p>(</span><span class=n>param</span><span class=o>.</span><span class=n>grad</span><span class=p>,</span> <span class=n>op</span><span class=o>=</span><span class=n>dist</span><span class=o>.</span><span class=n>ReduceOp</span><span class=o>.</span><span class=n>AVG</span><span class=p>)</span>
</span></span></code></pre></div><p>We&rsquo;re generating a lot of overhead. This is because for <em>every</em> single parameter, we&rsquo;re calling an all-reduce. Each of these is separate, so there&rsquo;s some overhead in setting up communications being done each and every time. Even if all the data is <em>small</em> it&rsquo;s a lot to do. Instead, we could use a bucketing strategy. This breaks the data up into larger chunks, combining data of up to about ~25MB together. This reduces the total amount of communications that need to get done. You can see a good implementation of this over <a href=https://github.com/huggingface/picotron/blob/main/picotron/data_parallel/data_parallel.py>in picotron</a>.</p><p>We won&rsquo;t implement it here, because we&rsquo;re interested in a different question. Let&rsquo;s hold that operation constant, and instead play with how long it takes to perform as we pull these two workers further from each other.</p><p>If I run the exact same code but on two different nodes without Remote Direct Memory Access (RDMA) it runs in about ~500ms. Worse still, but tolerable.</p><p>We can keep extending that distance, just based on what we know about the internet. We&rsquo;re transferring on the order of 18MB with each all-reduce here. On the same node, with PCIe we&rsquo;ve got a bandwidth of around ~10-25 Gbps. Latency will be short. On different nodes we&rsquo;ve got to kick on the network stack which increases our overhead (thus the 500ms). Not so bad.</p><p>But what if we don&rsquo;t <em>have</em> nodes on the same rack? What if they&rsquo;re not even in the same data center? What if we don&rsquo;t <em>have</em> a data center, and are instead sourcing compute from wherever we can get it?</p><figure><img loading=lazy src=smoke_em_if_you_got_em.png alt="Pic related: the wherever we can get it"><figcaption><p>Pic related: the wherever we can get it</p></figcaption></figure><p>In this world, we may be pushing those 18MB over regular old internet bandwidth. That might take the all-reduce to ~20 seconds. This is all with a relatively small model, and that parameter count and the gradients that have to be moved can get quite a bit larger as you scale the size of your model and the number of machines that have to communicate.</p><p>You want to train a big model. You might even have the dollars to spend on spot-compute. But you&rsquo;re data center poor and you want to do research with the big boys. What do you do?</p><h2 id=diloco---take-what-you-can-get>DiLoCo - Take What You Can Get<a hidden class=anchor aria-hidden=true href=#diloco---take-what-you-can-get>#</a></h2><p>So, our compute isn&rsquo;t shared in a single data center, but rather plucked from discrete nodes and clusters located all over the continent - or the world. We want to do data parallelism to increase our effective batch size, but it seems very likely if we use our current approach GPUs will spend most of their time idling due to expensive and slow network operations.</p><p>Our ideal technique would be one that&rsquo;s stackable (in that it uses data parallelism but does not prevent using other parallelisms), comfortable with heterogenous compute (different nodes/clusters with different GPUs), capable of communicating infrequently across a large geographic distance. Since we&rsquo;re GPU-poor and use spot instances, it would also save us a lot of gray hair if it was tolerant of nodes dropping out or joining partway through training.</p><p>As it turns out, that exists. It&rsquo;s called <a href=https://arxiv.org/abs/2311.08105>DiLoCo: Distributed Low-Communication Training of Language Models</a>.</p><h2 id=the-diloco-paper>The DiLoCo paper<a hidden class=anchor aria-hidden=true href=#the-diloco-paper>#</a></h2><p>If you&rsquo;ve done a brief read of HuggingFace&rsquo;s <a href=https://huggingface.co/spaces/nanotron/ultrascale-playbook>The Ultra-Scale Playbook</a><sup id=fnref:4><a href=#fn:4 class=footnote-ref role=doc-noteref>4</a></sup>, the DiLoCo paper is actually quite readable.</p><p>The basic setup mirrors data parallelism exactly. You&rsquo;ve got replicas of your model, deployed to potentially heterogenous compute. Just like standard data parallelism, each replica also has its own discrete part of the dataset available for training.</p><p>What&rsquo;s different is that each replica also saves the initial state of the model before training begins, and each replica has <em>two</em>. That initial state of the model copy is offloaded onto CPU, since it won&rsquo;t be used frequently. Onto the optimizers: the first is called the &ldquo;inner optimizer&rdquo;. It&rsquo;s a very standard AdamW optimizer in the paper, but it&rsquo;s whatever you would use for standard training. The inner optimizer loop is entirely normal, and does no communication between workers, and so does not incur any communication cost. You can add gradient accumulation as you like, whatever you need to get to an effective batch size you want for training.</p><p>In addition, training proceeds completely normally for a set amount of <em>inner steps</em> (let&rsquo;s call it $H$). Training proceeds independently for all nodes. $H$ is a hyperparameter, but to be useful it&rsquo;s set at something on the order of 500. That is, you&rsquo;re calling <code>optimizer.step()</code> on the inner optimizer 500 times before any communication happens between these disparate hosts.</p><p>So essentially you&rsquo;re training $n$ replicas of the model, one for each worker, starting from the same place and diverging as they update. How does this bubble up to a single trained model at the end?</p><p>The outer optimizer is responsible for that. Every $H$ steps, the outer optimizer loop happens. This is the tricky bit.</p><p>The outer optimization step collects <em>psuedo-gradients</em> by looking at the difference between the original weights it had the last time the outer optimizer was called. At the first step, this was be the pre-trained weights or the initial values of the weights. The psuedo gradients are <code>initial_parameter - replica_parameter</code> for each parameter in the neural network. These psuedo gradients are different for each worker, since they&rsquo;ve all been trained on different data and have been trained independently for these 500-odd steps.</p><p>An all-reduce is called on this step, so each worker averages these psuedo-gradients before calling the outer optimization step.</p><p>This outer optimizer is attached to the same weights as the inner optimizer, so when <code>outer_optimizer.step()</code> is called, each replica of the weights will be updated from the initial values with the same psuedo-gradients. So the replicas have once again been synced. A new copy of these weights is now stored in CPU for the next outer optimizer step, and training continues.</p><p>The inner-optimizer is not reset, so while each replica has the same weights, their AdamW keeps its first and second moment estimates. This results in transient training spikes, but doesn&rsquo;t cause a problem otherwise. Training continues until the desired amount of outer steps have been reached.</p><p>If this sounds miraculous and unlikely, it&rsquo;s probably because of your intuition about AdamW. AdamW is not what the outer optimizer is using. The paper very specifically uses <a href=https://machinelearningmastery.com/gradient-descent-with-nesterov-momentum-from-scratch/>Nesterov</a>.</p><p>Specifically, the paper says:</p><blockquote><p>We hypothesize that the Nesterov’s gradient correction is particularly helpful with the outer gradient that span hundred of training steps.</p></blockquote><p>An intuition about this is [intuition].</p><p>The paper ends with a series of ablations. What if compute joins or leaves during training? They find models end up generalizing well given a fixed compute budget, regardless of how that compute is made available over time. What if we do all of this on a single worker? Convergence speeds up. What if the communication is asynchronous and spotty, and outer gradient communications don&rsquo;t always reach a given worker? No problem, let the worker continue training the model for another round of $H$ inner-states and try again, it only slightly effects the final perplexity of the model. In general, the paper concludes that DiLoCo is just a vary robust algorithm for data parallelism.</p><p>This isn&rsquo;t pure research, either. Prime Intellect took it out on the road with <a href=https://www.primeintellect.ai/blog/intellect-1-release>Intellect-1</a>. Prime Intellect&rsquo;s training used their own DiLoCo implementation that supports <a href=https://huggingface.co/docs/accelerate/en/concept_guides/fsdp1_vs_fsdp2>FSDP2</a>. DiLoCo is used across nodes and FSDP within nodes. The resulting 10B parameter model converged, training on 14 concurrent nodes on three different continents, across 30 different compute providers.</p><p>A cool detail in the paper is that the all-reduce operation during the outer optimizer step took between one and seven minutes. This occurred after the inner optimization step roughly every 38 minutes. They chose $H$ to be a somewhat conservative 100 steps. This means that without DiLoCo, the all-reduce would&rsquo;ve needed to be incurred for every one of those 100 steps. That would mean roughly every 23 seconds a lag of 1-7 minutes would&rsquo;ve been introduced! Training would&rsquo;ve been totally infeasible.</p><p>Now that we&rsquo;re sufficiently motivated to understand <em>how cool</em> it is, let&rsquo;s implement a vanilla DiLoCo and see how it works.</p><h2 id=implementation>Implementation<a hidden class=anchor aria-hidden=true href=#implementation>#</a></h2><p>We&rsquo;re going to create a wrapper the same way we did it for vanilla data parallelism, with some tweaks.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>class</span> <span class=nc>Diloco</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> 
</span></span><span class=line><span class=cl>        <span class=n>model</span><span class=p>,</span> 
</span></span><span class=line><span class=cl>        <span class=n>inner_optimizer</span><span class=p>,</span> 
</span></span><span class=line><span class=cl>        <span class=n>outer_optimizer</span><span class=p>,</span> 
</span></span><span class=line><span class=cl>        <span class=n>warmup_steps</span><span class=p>,</span> 
</span></span><span class=line><span class=cl>        <span class=n>total_steps</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=n>inner_steps</span><span class=p>:</span> <span class=nb>int</span> <span class=o>=</span> <span class=mi>100</span><span class=p>,</span> 
</span></span><span class=line><span class=cl>        <span class=n>outer_steps</span><span class=p>:</span> <span class=nb>int</span> <span class=o>=</span> <span class=mi>10</span>
</span></span><span class=line><span class=cl>    <span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>model</span> <span class=o>=</span> <span class=n>model</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>inner_optimizer</span> <span class=o>=</span> <span class=n>inner_optimizer</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>outer_optimizer</span> <span class=o>=</span> <span class=n>outer_optimizer</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>scheduler</span> <span class=o>=</span> <span class=n>get_cosine_schedule_with_warmup</span><span class=p>(</span><span class=bp>self</span><span class=o>.</span><span class=n>inner_optimizer</span><span class=p>,</span> <span class=n>num_warmup_steps</span><span class=o>=</span><span class=n>warmup_steps</span><span class=p>,</span> <span class=n>num_training_steps</span><span class=o>=</span><span class=n>total_steps</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>param</span> <span class=ow>in</span> <span class=bp>self</span><span class=o>.</span><span class=n>model</span><span class=o>.</span><span class=n>parameters</span><span class=p>():</span>
</span></span><span class=line><span class=cl>            <span class=n>dist</span><span class=o>.</span><span class=n>broadcast</span><span class=p>(</span><span class=n>param</span><span class=o>.</span><span class=n>data</span><span class=p>,</span> <span class=n>src</span><span class=o>=</span><span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>offloaded_last_sync_parameters</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>_get_offloaded_parameters</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    
</span></span></code></pre></div><p>We&rsquo;ll distribute our initial weights the same way, again. We&rsquo;ll now need an <code>inner_optimizer</code> and an <code>outer_optimizer</code>, so we&rsquo;ll grab both of those.</p><p>After we&rsquo;ve synced, we want to offload our starting state into <code>self.offloaded_last_sync_parameters</code>. This will always be the current state of the model. Our inner optimizers run on and modify our specific replica trained on their own data. When we&rsquo;re ready for the outer step, we&rsquo;ll need the most recent synced copy of the parameters. We offloaded these to CPU to avoid keeping another copy in GPU vram.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>_get_offloaded_parameters</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=p>[</span>
</span></span><span class=line><span class=cl>		<span class=n>param</span><span class=o>.</span><span class=n>data</span><span class=o>.</span><span class=n>detach</span><span class=p>()</span><span class=o>.</span><span class=n>clone</span><span class=p>()</span><span class=o>.</span><span class=n>to</span><span class=p>(</span><span class=s2>&#34;cpu&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=k>for</span> <span class=n>group</span> <span class=ow>in</span> <span class=bp>self</span><span class=o>.</span><span class=n>outer_optimizer</span><span class=o>.</span><span class=n>param_groups</span>
</span></span><span class=line><span class=cl>		<span class=k>for</span> <span class=n>param</span> <span class=ow>in</span> <span class=n>group</span><span class=p>[</span><span class=s2>&#34;params&#34;</span><span class=p>]</span>
</span></span><span class=line><span class=cl>	<span class=p>]</span>
</span></span></code></pre></div><p>What used to be just <code>step</code> on the replicas in data parallelism is now our <code>inner_step</code>. Our inner step doesn&rsquo;t change very much. Though, this time I applied gradient clipping for smoother training, as well as a learning rate schedule since these are included in the paper.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>inner_step</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>	<span class=n>torch</span><span class=o>.</span><span class=n>nn</span><span class=o>.</span><span class=n>utils</span><span class=o>.</span><span class=n>clip_grad_norm_</span><span class=p>(</span><span class=bp>self</span><span class=o>.</span><span class=n>model</span><span class=o>.</span><span class=n>parameters</span><span class=p>(),</span> <span class=n>max_norm</span><span class=o>=</span><span class=mf>1.0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=bp>self</span><span class=o>.</span><span class=n>inner_optimizer</span><span class=o>.</span><span class=n>step</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=bp>self</span><span class=o>.</span><span class=n>scheduler</span><span class=o>.</span><span class=n>step</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=bp>self</span><span class=o>.</span><span class=n>inner_optimizer</span><span class=o>.</span><span class=n>zero_grad</span><span class=p>()</span>
</span></span></code></pre></div><p>The outer step is where things get properly interesting. Let&rsquo;s look at the conditions that cause it to fire, and then look at the implementation itself.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># ... normal train_dataloader setup</span>
</span></span><span class=line><span class=cl><span class=k>for</span> <span class=p>(</span><span class=n>i</span><span class=p>,</span> <span class=n>batch</span><span class=p>)</span> <span class=ow>in</span> <span class=nb>enumerate</span><span class=p>(</span><span class=n>train_dataloader</span><span class=p>):</span>
</span></span><span class=line><span class=cl>	<span class=n>real_step</span> <span class=o>=</span> <span class=p>(</span><span class=n>i</span> <span class=o>+</span> <span class=mi>1</span><span class=p>)</span> <span class=o>//</span> <span class=n>gradient_accumulation_steps</span>
</span></span><span class=line><span class=cl>	<span class=n>batch</span> <span class=o>=</span> <span class=p>{</span><span class=n>k</span><span class=p>:</span> <span class=n>v</span><span class=o>.</span><span class=n>to</span><span class=p>(</span><span class=n>device</span><span class=p>)</span> <span class=k>for</span> <span class=n>k</span><span class=p>,</span> <span class=n>v</span> <span class=ow>in</span> <span class=n>batch</span><span class=o>.</span><span class=n>items</span><span class=p>()}</span>
</span></span><span class=line><span class=cl>	<span class=n>output</span> <span class=o>=</span> <span class=n>diloco_model</span><span class=p>(</span><span class=o>**</span><span class=n>batch</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=n>loss</span> <span class=o>=</span> <span class=n>output</span><span class=o>.</span><span class=n>loss</span> <span class=o>/</span> <span class=n>gradient_accumulation_steps</span>
</span></span><span class=line><span class=cl>	<span class=n>output</span><span class=o>.</span><span class=n>loss</span><span class=o>.</span><span class=n>backward</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=p>(</span><span class=n>i</span> <span class=o>+</span> <span class=mi>1</span><span class=p>)</span> <span class=o>%</span> <span class=n>gradient_accumulation_steps</span> <span class=o>==</span> <span class=mi>0</span><span class=p>:</span>
</span></span><span class=line><span class=cl>		<span class=n>diloco_model</span><span class=o>.</span><span class=n>inner_step</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=n>real_step</span> <span class=o>%</span> <span class=n>inner_steps</span> <span class=o>==</span> <span class=mi>0</span><span class=p>:</span>
</span></span><span class=line><span class=cl>			<span class=n>diloco_model</span><span class=o>.</span><span class=n>outer_step</span><span class=p>()</span>
</span></span></code></pre></div><p>So we still have our gradient accumulation steps for the inner optimizer, and only called <code>inner_step</code> when we&rsquo;ve accumulated enough gradients to hit the batch size we&rsquo;re interested in.</p><p>After we&rsquo;ve called our inner step, we check to see whether we&rsquo;ve hit the proper number of <code>inner_steps</code>. This is the $H$ we discussed above. If we have, it&rsquo;s time to call the outer step.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>outer_step</span><span class=p>(</span><span class=bp>self</span><span class=p>)</span> <span class=o>-&gt;</span> <span class=kc>None</span><span class=p>:</span>
</span></span><span class=line><span class=cl>	<span class=s2>&#34;&#34;&#34;
</span></span></span><span class=line><span class=cl><span class=s2>	Outer step for Diloco.
</span></span></span><span class=line><span class=cl><span class=s2>	Loads last sync parameters from CPU to GPU and 
</span></span></span><span class=line><span class=cl><span class=s2>	  computes the psuedo-gradient for outer optimizer.
</span></span></span><span class=line><span class=cl><span class=s2>	Updates the offloaded parameters to CPU.
</span></span></span><span class=line><span class=cl><span class=s2>	&#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>	<span class=n>replica_params</span> <span class=o>=</span> <span class=p>[</span>
</span></span><span class=line><span class=cl>		<span class=n>param</span>
</span></span><span class=line><span class=cl>		<span class=k>for</span> <span class=n>group</span> <span class=ow>in</span> <span class=bp>self</span><span class=o>.</span><span class=n>inner_optimizer</span><span class=o>.</span><span class=n>param_groups</span>
</span></span><span class=line><span class=cl>		<span class=k>for</span> <span class=n>param</span> <span class=ow>in</span> <span class=n>group</span><span class=p>[</span><span class=s2>&#34;params&#34;</span><span class=p>]</span>
</span></span><span class=line><span class=cl>	<span class=p>]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=n>replica_param</span><span class=p>,</span> <span class=n>last_sync_param</span> <span class=ow>in</span> <span class=nb>zip</span><span class=p>(</span><span class=n>replica_params</span><span class=p>,</span> <span class=bp>self</span><span class=o>.</span><span class=n>offloaded_last_sync_parameters</span><span class=p>):</span>
</span></span><span class=line><span class=cl>		<span class=n>last_sync_param_on_device</span> <span class=o>=</span> <span class=n>last_sync_param</span><span class=o>.</span><span class=n>to</span><span class=p>(</span><span class=n>replica_param</span><span class=o>.</span><span class=n>device</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=n>replica_param</span><span class=o>.</span><span class=n>grad</span> <span class=o>=</span> <span class=n>last_sync_param_on_device</span> <span class=o>-</span> <span class=n>replica_param</span><span class=o>.</span><span class=n>data</span>
</span></span><span class=line><span class=cl>		<span class=n>dist</span><span class=o>.</span><span class=n>all_reduce</span><span class=p>(</span><span class=n>tensor</span><span class=o>=</span><span class=n>replica_param</span><span class=o>.</span><span class=n>grad</span><span class=p>,</span> <span class=n>op</span><span class=o>=</span><span class=n>dist</span><span class=o>.</span><span class=n>ReduceOp</span><span class=o>.</span><span class=n>AVG</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=n>replica_param</span><span class=o>.</span><span class=n>data</span> <span class=o>=</span> <span class=n>last_sync_param_on_device</span>
</span></span><span class=line><span class=cl>	
</span></span><span class=line><span class=cl>	<span class=bp>self</span><span class=o>.</span><span class=n>outer_optimizer</span><span class=o>.</span><span class=n>step</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=bp>self</span><span class=o>.</span><span class=n>outer_optimizer</span><span class=o>.</span><span class=n>zero_grad</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=bp>self</span><span class=o>.</span><span class=n>offloaded_last_sync_parameters</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>_get_offloaded_parameters</span><span class=p>()</span>
</span></span></code></pre></div><p>First we get our current replica parameters so they can be zipped against our last synced ones. <code>replica_param</code> is the current state of the model that&rsquo;s already loaded into GPU memory we&rsquo;ve been optimizing.</p><p>First, briefly, we read the offloaded parameters into GPU memory. At this point, there aren&rsquo;t any activations being computed, so the storing the additional model on device briefly isn&rsquo;t super painful. Then, you set the recently zeroed gradient of the on device model to the difference between the last sync, and the replicas current understanding of the world. This distance becomes the psuedo gradient. Then, you perform an all-reduce, so the gradients now represent the average distance between the last synced model and its replicas. Finally, you place the last synced model parameter data over the replicas weights.</p><p>So very briefly, you overwrite all of your progress. The models are right back to their starting state! But crucially, they&rsquo;re back to their starting state with our psuedo-gradient information. All that&rsquo;s left to do is take your step. As soon as that step occurs on each replica, the models have made a large update with information from the training they each did independently. Finally, you overwrite the last sync parameters by offloading the new weights you&rsquo;ve computed into CPU for the next step, and continue training as normal.</p><h2 id=results>Results<a hidden class=anchor aria-hidden=true href=#results>#</a></h2><figure><img loading=lazy src=diloco_train.png alt="It runs!"><figcaption><p>It runs!</p></figcaption></figure><p>If you want to try this for yourself, you can check out my repo here for <a href=https://github.com/SJCaldwell/NanoDiloco>NanoDiloco</a>. The wandb logs are <a href="https://wandb.ai/sjcaldwell/nano-dilco/workspace?nw=nwusersjcaldwell">here</a>. If you want to see what production grade DiLoCo looks like, Prime Intellect has a beautiful repo for it <a href=https://github.com/PrimeIntellect-ai/prime/blob/de5b9317da5f57247f11abed2fca259076795460/src/zeroband/diloco.py#L24>here</a>.</p><p>And to Zach, who I hope reads this: great class! I&rsquo;ve found in general it&rsquo;s easy to find teachers if the thing you want to learn is ~5 years out of date, but the closer you get to the cutting edge the rarer it is to find someone who is both gifted at doing the work itself as well as concisely communicating that understanding to other people, pulling all the pedagogical knobs and levers required.</p><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p>&ldquo;Look at the crummy latency on this model, look at the dumb mistakes it makes, and how limited its labels are! We could never go to prod with this. Now, let&rsquo;s talk about our labeling budget&mldr;&rdquo;&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:2><p>That age-old ill. Eventually I will be old enough where I stop doing it.&#160;<a href=#fnref:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:3><p>Or just placing your faith in <a href=https://github.com/unslothai/unsloth>Unsloth</a> and riding that single GPU as far as it&rsquo;ll go&#160;<a href=#fnref:3 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:4><p>And if you haven&rsquo;t, you should! It&rsquo;s an excellent introduction to different parallelism strategies necessary for training modern models.&#160;<a href=#fnref:4 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div></div><footer class=post-footer><ul class=post-tags><li><a href=http://localhost:1313/tags/llms/>Llms</a></li><li><a href=http://localhost:1313/tags/training/>Training</a></li><li><a href=http://localhost:1313/tags/distributed/>Distributed</a></li></ul><nav class=paginav><a class=next href=http://localhost:1313/writing/rl-llms-and-priors/><span class=title>Next »</span><br><span>RL Needed LLMs Because Agency Requires Priors</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2025 <a href=http://localhost:1313/>Shane Caldwell</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><style>.copy-code{display:inline-flex;align-items:center;justify-content:center;width:32px;height:32px;background:var(--tertiary);border:1px solid var(--border);border-radius:6px;color:var(--secondary);cursor:pointer;transition:all .2s ease;position:absolute;top:8px;right:8px;z-index:10}.copy-code:hover{background:var(--secondary);color:var(--theme)}.copy-code svg{width:16px;height:16px}.copy,.highlight .copy{display:none!important}pre{position:relative}</style><script>document.addEventListener("DOMContentLoaded",function(){document.querySelectorAll('.copy, [class*="copy"]').forEach(e=>{e.classList.contains("copy-code")||e.remove()});const e=document.querySelectorAll("pre");e.forEach(e=>{const t=e.cloneNode(!0);e.parentNode.replaceChild(t,e)}),document.querySelectorAll("pre code").forEach(e=>{const n=e.parentElement;if(n.querySelector(".copy-code"))return;const t=document.createElement("button");t.classList.add("copy-code"),t.setAttribute("aria-label","Copy code"),t.setAttribute("type","button");const s=`<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect width="14" height="14" x="8" y="8" rx="2" ry="2"/><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"/></svg>`,a=`<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M20 6L9 17l-5-5"/></svg>`;t.innerHTML=s;function o(){t.innerHTML=a,t.style.color="#10b981",setTimeout(()=>{t.innerHTML=s,t.style.color=""},2e3)}t.addEventListener("click",function(t){t.preventDefault(),t.stopPropagation();const n=e.textContent||e.innerText;navigator.clipboard?navigator.clipboard.writeText(n).then(()=>{o()}).catch(()=>{i(n)}):i(n)});function i(e){const t=document.createElement("textarea");t.value=e,t.style.position="fixed",t.style.opacity="0",document.body.appendChild(t),t.select();try{document.execCommand("copy"),o()}catch(e){console.error("Copy failed:",e)}document.body.removeChild(t)}n.appendChild(t)})})</script><script>window.MathJax={tex:{inlineMath:[["$","$"],["\\(","\\)"]],displayMath:[["$$","$$"],["\\[","\\]"]],processEscapes:!0,processEnvironments:!0},chtml:{scale:1,mtextInheritFont:!1,matchFontHeight:!1},options:{skipHtmlTags:["script","noscript","style","textarea","pre"]},startup:{pageReady:()=>MathJax.startup.defaultPageReady().then(()=>{document.querySelectorAll("mjx-container").forEach(e=>{e.style.overflow="visible"})})}}</script><script id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js></script><style>.footnote-popup{position:absolute;background:var(--theme);border:1px solid var(--border);border-radius:6px;padding:12px 16px;max-width:300px;font-size:.85em;line-height:1.4;z-index:1000;box-shadow:0 4px 12px rgba(0,0,0,.15);font-family:var(--font-mono);color:var(--primary);display:none;pointer-events:auto;word-wrap:break-word}.dark .footnote-popup{background:#2d2d2d;box-shadow:0 4px 12px rgba(0,0,0,.3)}.footnote-popup::before{content:'';position:absolute;top:-6px;left:50%;transform:translateX(-50%);width:12px;height:12px;background:var(--theme);border:1px solid var(--border);border-bottom:none;border-right:none;rotate:45deg}.dark .footnote-popup::before{background:#2d2d2d}.footnote-ref{text-decoration:none!important;font-weight:700;padding:2px 6px;border-radius:4px;background:var(--primary);color:var(--theme)!important;transition:all .2s ease;position:relative;border:1px solid var(--border);font-size:.8em;line-height:1.2;display:inline-block;min-width:18px;text-align:center;margin:0 1px;vertical-align:baseline}.footnote-ref:hover{background:var(--secondary);color:var(--theme)!important;box-shadow:0 2px 4px rgba(0,0,0,.2)}.dark .footnote-ref{background:#fff;color:#000!important;border:1px solid #666}.dark .footnote-ref:hover{background:#e5e5e5;color:#000!important;box-shadow:0 2px 6px rgba(0,0,0,.4)}</style><script>document.addEventListener("DOMContentLoaded",function(){let e=null,t=null;function s(e,t){const n=document.createElement("div");return n.className="footnote-popup",n.innerHTML=t,document.body.appendChild(n),n}function o(n,s){t&&(clearTimeout(t),t=null);const i=n.getBoundingClientRect(),r=s.getBoundingClientRect();let o=i.left+i.width/2-s.offsetWidth/2,a=i.top-s.offsetHeight-10;o<10&&(o=10),o+s.offsetWidth>window.innerWidth-10&&(o=window.innerWidth-s.offsetWidth-10),a<10&&(a=i.bottom+10),s.style.left=o+window.scrollX+"px",s.style.top=a+window.scrollY+"px",s.style.display="block",e=s}function n(){t=setTimeout(()=>{e&&(e.style.display="none",e=null)},150)}document.querySelectorAll("a.footnote-ref").forEach(e=>{const i=e.getAttribute("href");if(!i)return;const r=document.querySelector(i.replace(/:/g,"\\:"));if(!r)return;const c=r.innerHTML.replace(/<a[^>]*href="#fnref[^"]*"[^>]*>.*?<\/a>/g,"").trim();if(!c)return;const a=s(i,c);e.addEventListener("mouseenter",()=>{o(e,a)}),e.addEventListener("mouseleave",n),a.addEventListener("mouseenter",()=>{t&&(clearTimeout(t),t=null)}),a.addEventListener("mouseleave",n)}),window.addEventListener("scroll",()=>{e&&(e.style.display="none",e=null)})})</script><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>